{"meta":{"title":"Jason's blog","subtitle":"Tech blog","description":"I'm a software engineer","author":"Jason Lee","url":"http://jason0853.github.io"},"pages":[],"posts":[{"title":"React Basic","slug":"React-Basic","date":"2018-08-15T05:51:56.000Z","updated":"2019-05-18T06:10:55.393Z","comments":true,"path":"2018/08/15/React-Basic/","link":"","permalink":"http://jason0853.github.io/2018/08/15/React-Basic/","excerpt":"","text":"오랜만에 Velopert 님의 인프런 강의(리액트)를 보고 정리하는 차원에서 리액트 관련 포스팅을 작성해보겠습니다. # Use Create-React-App123$ npx create-react-app react-basic$ cd react-basic$ yarn start Facebook 에서 제공하는 create-react-app CLI 툴을 사용하여 리액트 프로젝트를 사용하였습니다. # jsconfig.json and .eslintrc12$ yarn add --dev prettier-eslint$ touch jsconfig.json .eslintrc jsconfig.json12345&#123; \"compilerOptions\": &#123; \"baseUrl\": \"./\" &#125;&#125; package.json12345678//(중략...)\"scripts\": &#123; \"start\": \"NODE_PATH=src react-scripts start\", \"build\": \"NODE_PATH=src react-scripts build\", \"test\": \"react-scripts test --env=jsdom\", \"eject\": \"react-scripts eject\" &#125;,//(중략...) .eslintrc1234567&#123; \"extends\": [\"react-app\"], \"rules\": &#123; \"quotes\": [\"error\", \"single\", &#123; \"avoidEscape\": true &#125;], \"indent\": [\"error\", 2] &#125;&#125; baseUrl 옵션에 src 폴더를 root 로 지정해줍니다. 서버를 실행하는 명령어 구문에 NODE_PATH=src를 추가해줍니다. prettier-eslint는 코드를 일관성 있게 작성해주는 package 입니다. # JSXReact 를 이제 본격적으로 시작해보겠습니다. 리액트에는 JSX라는 특이한 문법을 가지고 있는데 이 syntax 에 대해 다뤄보겠습니다. class가 아닌 className이라고 사용하는 것이 올바른 convention 입니다. 스타일을 작성할 때도 객체로 작성하셔야합니다. 기존 css 에서 스타일 주는 것과 차이점은 property 를 대쉬(-)가 아닌 camelCase 로 작성하셔야합니다. 배열의 있는 값들을 반복문으로 순환할 때는 map 메소드를 사용하여 새로운 배열로 반환시킵니다. 주의할 점은 리액트에서 배열을 렌더링을 할 때 꼭 필요한 것이 key값입니다. key라는 고유한 값을 통하여 배열의 값이 변경될 때 성능 최적화를 시킬 수 잇습니다. jsx 문법에서 가장 좋은 점은 자바스크립트 문법을 자유롭게 사용할 수 있는 것입니다. 위에서 보신바와 같이 &amp;&amp; 연산자를 사용할 수 있고 삼항연산자를 사용할 수도 있습니다.예) completed ? success : fail 컴포넌트에서 DOM 태그를 리턴시킬 때 항상 닫힌 태그여야하며 상위 Element 가 존재하여야합니다. 상위 Element 를 피하고 싶은 경우에는 Fragment를 이용하시기 바랍니다. # Props &amp;&amp; State이제부터는 리액트에서 가장 중요한 개념이라고 생각되는 props 와 state 에 대해 다뤄보겠습니다. props리액트에서 자식 컴포넌트로 값을 전달해줄때 props 를 이용합니다. 하지만 값을 전달만 할 뿐이지 직접 수정할 수는 없습니다. MyName 이라는 컴포넌트를 만들어 App 컴포넌트에서 렌더링 시켜줍니다. name이라는 props 를 주게 되면 할당된 값이 전달됩니다. 하지만 props 를 전달해주지 않으면 defaultProps에 미리 정의된 값이 노출됩니다. 함수형 컴포넌트로 만들어서 렌더링 시킬 경우 미세하게나마 성능이 향상됩니다. state컴포넌트 내부에서 state 값을 선언할 수 있으며 수정할 수 있습니다. state 값을 선언하고 나서 값을 수정하고 싶은 경우 항상 setState함수를 이용하여 값을 변경해야합니다. Arrow function 을 사용해서 함수를 생성한다면 이벤트에 bind 할 때 this 문제를 해결할 수 있습니다. # LifeCycle API아래 코드는 velopert 님 강의에서 나온 코드 위주로 정리한 LifeCycle API 자료입니다. Wrap-upVelopert 님의 인프런 강의 내용이 워낙 알차다보니 정리하고 넘어가면 좋을것 같아서 포스팅하게 되었습니다. 기초로 돌아가 공부하다 보면 프로젝트 진행하면서 제가 아쉽게 짜던 코드들이 기억이 남습니다. 예를 들면 LifeCycle API 를 잘 사용했다면 좀 더 쉽게 구현할 수 있었을텐데 하는 아쉬움 같은거 말이죠?ㅋㅋㅋ Reference누구든지 하는 리액트: 초심자를 위한 리액트 핵심 강좌","categories":[{"name":"Front-end","slug":"Front-end","permalink":"http://jason0853.github.io/categories/Front-end/"},{"name":"React","slug":"Front-end/React","permalink":"http://jason0853.github.io/categories/Front-end/React/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://jason0853.github.io/tags/Javascript/"},{"name":"React","slug":"React","permalink":"http://jason0853.github.io/tags/React/"}]},{"title":"Config create-react-app with sass and spritesmith","slug":"Config-create-react-app-with-sass-and-spritesmith","date":"2018-05-28T05:58:57.000Z","updated":"2019-05-18T06:10:55.393Z","comments":true,"path":"2018/05/28/Config-create-react-app-with-sass-and-spritesmith/","link":"","permalink":"http://jason0853.github.io/2018/05/28/Config-create-react-app-with-sass-and-spritesmith/","excerpt":"","text":"이번에 웹앱 프로젝트를 진행하면서 css 모듈화와 이미지 자동화를 위해 Sass와 Spritesmith를 페이스북에서 제공하는 create-react-app과 어떻게 사용하는지 알아보겠습니다. # Create-react-app우선 기본 셋팅을 하기 위해 폴더를 생성하고 생성된 폴더 안에서 create-react-app을 사용하여 리액트 프로젝트를 생성해보겠습니다. 123$ mkdir create-react-app-for-sass-and-spritesmith &amp;&amp; cd create-react-app-for-sass-and-spritesmith$ npx create-react-app .$ yarn eject yarn eject를 실행하면 Are you sure you want to eject? This action is permanent. 이런 메세지가 나옵니다. y를 입력해주시면 webpack을 customize 할 수 있게 config 폴더가 생성됩니다. # How to config sass with webpackSass 환경을 위해 필요한 package들을 yarn을 통해 설치해보겠습니다. 1$ yarn add node-sass sass-loader node-sass: sass 파일들을 css파일로 변환해주는 역할을 합니다. sass-loader: webpack에서 sass 파일들을 읽어오는 역할을 합니다 paths.js12345// ...(중략)...module.exports = &#123; // ...(중략)... styles: resloveApp('src/styles') // styles 폴더 경로 지정&#125; scss 모듈들을 쉽게 불러올 수 있도록 styles 폴더를 루트로 지정하였습니다. 이 모듈을 불러와서 webpack에서 설정하겠습니다. webpack.config.dev.js12345678910111213141516171819202122232425262728293031323334353637383940414243444546// ...(중략)...&#123; test: /\\.css$/, // ...(중략)...&#125;,&#123; test: /\\.scss$/, use: [ require.resolve('style-loader'), &#123; loader: require.resolve('css-loader'), options: &#123; importLoaders: 1, sourceMap: true &#125;, &#125;, &#123; loader: require.resolve('postcss-loader'), options: &#123; // Necessary for external CSS imports to work // https://github.com/facebookincubator/create-react-app/issues/2677 ident: 'postcss', plugins: () =&gt; [ require('postcss-flexbugs-fixes'), autoprefixer(&#123; browsers: [ '&gt;1%', 'last 4 versions', 'Firefox ESR', 'not ie &lt; 9', // React doesn't support IE8 anyway ], flexbox: 'no-2009', &#125;), ], &#125;, &#125;, // sass-loader 추가 &#123; loader: require.resolve('sass-loader'), options: &#123; // path 추가 includePaths: [paths.styles] &#125; &#125; ],&#125;, 기존 webpack.config.dev.js 안에 있는 css 설정을 바로 밑에 복사한 다음 /&#92;.scss$/로 확장자를 바꿔줍니다. style-loader: style 태그를 injecting 시킴으로써 DOM에 css를 추가해줍니다. css-loader: @import와 url()을 import와 require()와 같이 해석하여 해결해줍니다. 우리가 입력한 css 코드에 prefix(-webkit--mos--ms-)를 자동으로 붙여줍니다. 개발하면서 css 디버깅을 위해 options에 sourceMap: true 코드를 추가해줍니다. 맨 마지막으로 sass-loader 설정을 해주고 options에 scss 모듈들을 쉽게 import 할 수 있도록 경로 설정을 추가해줍니다. webpack.config.prod.js1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859// ...(중략)...&#123; test: /\\.css$/, // ...(중략)...&#125;,&#123; test: /\\.scss$/, loader: ExtractTextPlugin.extract( Object.assign( &#123; fallback: &#123; loader: require.resolve('style-loader'), options: &#123; hmr: false, &#125;, &#125;, use: [ &#123; loader: require.resolve('css-loader'), options: &#123; importLoaders: 1, minimize: true, sourceMap: shouldUseSourceMap, &#125;, &#125;, &#123; loader: require.resolve('postcss-loader'), options: &#123; // Necessary for external CSS imports to work // https://github.com/facebookincubator/create-react-app/issues/2677 ident: 'postcss', plugins: () =&gt; [ require('postcss-flexbugs-fixes'), autoprefixer(&#123; browsers: [ '&gt;1%', 'last 4 versions', 'Firefox ESR', 'not ie &lt; 9', // React doesn't support IE8 anyway ], flexbox: 'no-2009', &#125;), ], &#125;, &#125;, &#123; loader: require.resolve('sass-loader'), options: &#123; // path 추가 includePaths: [paths.styles] &#125; &#125;, ], &#125;, extractTextPluginOptions ) ), // Note: this won't work without `new ExtractTextPlugin()` in `plugins`.&#125;, webpack.config.prod.js 파일 또한 기존 css 설정을 바로 밑에 복사한 다음 /&#92;.scss$/로 확장자를 바꿔줍니다. # How to config spritesmith with webpack이번엔 이미지 자동화를 위해 spritesmith를 webpack에 적용해보겠습니다. 1$ yarn add webpack-spritesmith env.js123456789101112131415161718192021// ...(중략)...// spritesmith plugin 설정 const configSprite = &#123; src: &#123; cwd: path.resolve(__dirname, '../src/assets/ico'), glob: '*.png' &#125;, target: &#123; image: path.resolve(__dirname, '../src/assets/sprites/sprite.png'), css: path.resolve(__dirname, '../src/styles/sprite.scss') &#125;, retina: '@2x', apiOptions: &#123; cssImageRef: \"~sprite.png\" &#125;, &#125;; return &#123; raw, stringified, configSprite &#125;;&#125;module.exports = getClientEnvironment; config 폴더 안에 있는 env.js에서 미리 spritesmith 관련 환경설정을 미리 해줍니다. retina: ‘@2x’ 옵션은 sprite@2x.png를 생성시켜줍니다. webpack.config.dev.js12345678910111213141516171819// ...(중략)...const SpritesmithPlugin = require('webpack-spritesmith'); // ...(중략)... resolve: &#123; // This allows you to set a fallback for where Webpack should look for modules. // We placed these paths second because we want `node_modules` to \"win\" // if there are any conflicts. This matches Node resolution mechanism. // https://github.com/facebookincubator/create-react-app/issues/253 // sprites 폴더 경로 추가 modules: ['node_modules', paths.appNodeModules, 'assets/sprites'].concat( // It is guaranteed to exist because we tweak it in `env.js` process.env.NODE_PATH.split(path.delimiter).filter(Boolean) ), // ...(중략)... plugins: [ // ...(중략)... // SpritesmithPlugin 추가 new SpritesmithPlugin(env.configSprite) ] yarn으로 설치한 webpack-spritesmith 플러그인을 불러와 webpack에 설정을 해줍니다. ‘assets/sprites’를 modeuls 속성 배열안에 추가해준 이유는 모듈(~sprite.png) 형태로 불러오는것을 해결해주기 위함입니다. webpack.config.prod.js1234567891011// ...(중략)... resolve: &#123; // This allows you to set a fallback for where Webpack should look for modules. // We placed these paths second because we want `node_modules` to \"win\" // if there are any conflicts. This matches Node resolution mechanism. // https://github.com/facebookincubator/create-react-app/issues/253 // sprites 폴더 경로 추가 modules: ['node_modules', paths.appNodeModules, 'assets/sprites'].concat( // It is guaranteed to exist because we tweak it in `env.js` process.env.NODE_PATH.split(path.delimiter).filter(Boolean) ), production 레벨에서는 경로만 추가해줍니다. build를 해주기 전에는 yarn start를 한 뒤에 yarn build를 해주시기 바랍니다. Wrap-up처음 환경 셋팅을 할 때 webpack-spritesmith 때문에 삽질을 많이 했었는데 이번에 이렇게 정리하고 나니 다음에는 copy and paste를 하면 될 것 같습니다. 전체 내용 코드는 아래 github repository에서 확인하실 수 있습니다. Reference리액트 컴포넌트 스타일링webpack-spritesmith","categories":[{"name":"Front-end","slug":"Front-end","permalink":"http://jason0853.github.io/categories/Front-end/"},{"name":"React","slug":"Front-end/React","permalink":"http://jason0853.github.io/categories/Front-end/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://jason0853.github.io/tags/React/"},{"name":"Sass","slug":"Sass","permalink":"http://jason0853.github.io/tags/Sass/"},{"name":"Spritesmith","slug":"Spritesmith","permalink":"http://jason0853.github.io/tags/Spritesmith/"}]},{"title":"React and Redux with Typescript","slug":"React-and-Redux-with-Typescript","date":"2018-05-12T08:06:26.000Z","updated":"2019-05-18T06:10:55.393Z","comments":true,"path":"2018/05/12/React-and-Redux-with-Typescript/","link":"","permalink":"http://jason0853.github.io/2018/05/12/React-and-Redux-with-Typescript/","excerpt":"","text":"최근 회사에서 리액트&amp;리덕스를 사용하여 웹앱 프로젝트를 진행하고 있는 와중에 타입스크립트도 개인적으로 공부하고 있었습니다. 그래서 ‘이 두 가지를 같이 사용하면 어떨까?’라는 생각을 하게 되었습니다. 다음 프로젝트를 위해 미리 포스팅을 작성하면서 공부해보겠습니다. # Create react app with typescript123$ create-react-app react-redux-ts --scripts-version=react-scripts-ts$ cd react-redux-typescript-tutorial$ yarn start Microsoft에서 미리 react와 typescript 초기 설정에 대한 CLI를 제공해줍니다. react-redux-typescript-tutorial 폴더로 이동하고 yarn start를 실행해보겠습니다.주의) 혹시 브라우저에서 Duplicate identifier ‘URL’ 에러가 나는 경우 @types/node 버전을 바꿔주시길 바랍니다. -&gt; yarn add –dev @types/node@9.6.7 # Configure우선 첫 component를 만들기에 앞서 src 폴더 안에 있는 logo.svg, App.css, App.test.tsx를 삭제하겠습니다.그리고 나서 App.tsx 파일 내용은 아래와 같이 바꿔주시길 바랍니다. package.json12345678//(중략...)\"scripts\": &#123; \"start\": \"NODE_PATH=src react-scripts-ts start\", \"build\": \"NODE_PATH=src react-scripts-ts build\", \"test\": \"react-scripts-ts test --env=jsdom\", \"eject\": \"react-scripts-ts eject\" &#125;,//(중략...) tsconfig.json1234&#123; \"compilerOptions\": &#123; \"baseUrl\": \"./src\",//(중략...) tslint.json123456789101112&#123; \"extends\": [\"tslint-react\", \"tslint-config-prettier\"], \"linterOptions\": &#123; \"exclude\": [ \"config/**/*.js\", \"node_modules/**/*.ts\" ] &#125;, \"rules\": &#123; \"jsx-no-lambda\": false &#125;&#125; 절대 경로로 파일을 불러올 수 있도록 package.json, tsconfig.json의 파일을 위와 같이 수정해줍니다.예) import Person from components/Person tslint.json 파일 안에 “tslint:recommended”가 들어가 있다면 삭제하고 “jsx-no-lambda” : false로 설정을 추가해줍니다. 1$ yarn start 브라우저에 App component가 잘 렌더링됩니다. # Create first componentTypescript를 이용하여 component를 생성할 때는 .tsx 확장자를 사용합니다. 12345678// 폴더 구조src - components Person.tsx App.tsx index.css index.tsx registerServiceWorker.ts 기존 자바스크립트에서는 prop-types를 이용하여 타입 checking을 해왔었습니다. 하지만 타입스크립트에서는 interface 및 type를 이용하여 props 및 state에 타입을 지정해줍니다. type 에러가 날 경우 예전과 달리 런타임 전에 error를 확인하실 수 있습니다. 함수형 Component로 작성할 경우 React.SFC를 사용하여 타입을 지정해주는 것이 권장사항입니다. # Smart component &amp; Dumb component이번엔 smart component(state 및 life cycle api가 필요한 컴포넌트)와 dumb component(style 및 단순 props 전달받을 컴포넌트)로 나누어 연습해보겠습니다. 1234567891011// 폴더 구조src - components Counter.tsx Person.tsx - containers CounterContainer.tsx App.tsx index.css index.tsx registerServiceWorker.ts CounterContainer(Smart Component)의 state 값과 함수들을 Counter(Dumb Component)의 props로 전달해줍니다. interface가 없는 경우엔 Generic 타입을 빈 객체로 지정해줍니다.예) &lt;{}, State&gt; # Create Todo ListTodo List를 한번 만들어 보면서 컴포넌트 최적화 및 여러가지 기능들을 구현해보겠습니다. 123456789101112131415// 폴더 구조src - components Counter.tsx Person.tsx TodoForm.tsx TodoItem.tsx TodoList.tsx - containers CounterContainer.tsx TodoContainer.tsx App.tsx index.css index.tsx registerServiceWorker.ts TodoList, TodoItem을 함수형 컴퍼넌트로 만들지 않은 이유는 LifeCycle API인 shouldComponentUpdate(nextProps, nextState)를 이용하여 컴퍼넌트 최적화를 해야하기 때문입니다. 만약 최적화 작업이 이루어지지 않는다면 Virtual Dom에서 필요없는 resource가 렌더링됩니다. 특히 TodoItem의 갯수가 기하급수적으로 늘어난다면 필요없는 자원들로 인해 결국 렌더링 속도가 느려질 것입니다. # Combine Redux with Typescript이제 Redux와 Typescript를 함께 사용해보겠습니다. 시작하기에 앞서 필요한 패키지들을 설치해보겠습니다. 12$ yarn add redux react-redux redux-actions immer$ yarn add @types/redux @types/react-redux @types/redux-actions immer 패키지 안에 type definitions이 이미 내장되어 있기 때문에 타입 패키지를 따로 설치하지 않아도 됩니다. 수정된 파일과 추가된 파일이 너무 많아 아래 깃헙 소스에서 코드를 검토해주세요.ㅎㅎCombine Redux with Typescript 커밋 로그를 수정된 소스와 추가된 파일 소스를 바로 확인하실 수 있습니다. 1234567891011121314// 폴더 구조src - store - models counter.ts index.ts todo.ts - modules counter.ts index.ts todo.ts actionCreators.ts configure.ts index.ts 기존 src 폴더 안에 store 폴더를 추가한 다음 redux 관련 코드는 modules 폴더에 분류하고 state, action payload, action creator의 type definition을 models 폴더에 분류합니다. state 및 props는 type(type alias)를 사용하고 actionCreator methods들은 interface로 타입지정을 합니다.주의) 액션 함수들을 interface로 타입 지정을 할 경우 [key: string]: any;를 하지 않으면 index signature is missing in type ~~에러가 나기 때문에 추가해줍니다. actionCreators.ts 파일을 따로 만들어 액션 파일들을 따로 관리해주는 이유는 smart component에서 connect함수에 연결시켜서 props로 가져오는 번거러움을 덜어주기 위함입니다.예) this.props.CounterActions.increase();가 아닌 CounterActions.increase(); Reducers 코드를 작성할 때 action.payload 타입이 undefined 에러가 나는 경우가 있습니다. 그 이유는 Action 인터페이스가 payload가 없어도 될 수 있도록 설계되어 있기 때문에 예외처리를 따로 해주어야합니다. action.payload! - payload가 항상 있을 경우 action.payload &amp;&amp; do something - aciton.payload가 참일 경우에만 Wrap-up리액트, 리덕스, 타입스크립트를 함께 사용하며 느낀 점은 타입 지정 때문에 기존보다 코딩 시간이 오래 걸리는 것 같이 느끼지만 적응하다보니 좀 더 풍부한 장점을 누릴 수 있었습니다. 특히 vscode랑 같이 쓰다 보니 자동완성 및 마우스 hover를 할 경우 어떤 타입인지 노출시켜줍니다. 그렇기 때문에 파일을 이동하며 확인해 볼 필요가 없어집니다. 또한 저희가 할 수 있는 사소한 실수를 에디터에서 바로 알려줍니다. 저같은 경우는 앞으로 타입스크립트를 도입하여 작업하는 환경이 점점 늘어날 것 같습니다. ReferenceTypeScript with React + Redux/Immutable.js 빠르게 배우기ImmerInterface vs Type alias in TypeScript 2.7","categories":[{"name":"Front-end","slug":"Front-end","permalink":"http://jason0853.github.io/categories/Front-end/"},{"name":"React","slug":"Front-end/React","permalink":"http://jason0853.github.io/categories/Front-end/React/"}],"tags":[{"name":"Typescript","slug":"Typescript","permalink":"http://jason0853.github.io/tags/Typescript/"},{"name":"React","slug":"React","permalink":"http://jason0853.github.io/tags/React/"},{"name":"Redux","slug":"Redux","permalink":"http://jason0853.github.io/tags/Redux/"},{"name":"Immer","slug":"Immer","permalink":"http://jason0853.github.io/tags/Immer/"}]},{"title":"Docker Basic","slug":"Docker-Basic","date":"2018-04-23T04:36:13.000Z","updated":"2019-05-18T06:10:55.393Z","comments":true,"path":"2018/04/23/Docker-Basic/","link":"","permalink":"http://jason0853.github.io/2018/04/23/Docker-Basic/","excerpt":"","text":"요즘 인프라에 대해 관심이 생기면서 자연스럽게 Docker에 대해 관심을 가지게 되었습니다. Docker에 대해 1도 몰랐던 개발자들에게 도움이 되고자 포스팅을 한 번 해보겠습니다. 이번 포스팅은 Docker의 기본 개념과 자주 쓰는 명령어에 대해 간락히 살펴보겠습니다. What is Docker?Docker에 대해 검색을 해보니 Virtual Machine(VM Ware / Virtual Box)과 유사한 기능을 가진 것처럼 보입니다. 기존의 Virtual Machine 같은 경우 Host OS가 깔리고 그 위에 VM Ware나 Virtual Box를 설치한 이후에 다양한 종류의 OS(Linux나 Windows)를 설치합니다. 즉, 하드웨어를 가상화 한 것이라고 보면 됩니다. 상당히 무겁고 운영환경에서 쓰기에 이슈가 많습니다. 그와 반대로 도커는 Host OS가 깔리고 그 위에 Docker Engine이 실행되며 Container 위에서 Linux 기반의 OS만 수행이 가능합니다. 여기서 중요하게 봐야할 부분은 컨터이너라는 격리된 공간에서 프로세스가 동작하는 기술입니다. 에를 들어 여러 개의 컨테이너를 동시에 띄워도 독립적으로 실행되기 때문에 아주 가볍고 빠르게 동작합니다. 또한 컨테이너를 설치하는 시간은 기존의 가상머신(VM Ware나 Virtual Box) 위에 OS를 설치하는 것과 비교할 수 없을 정도로 빠릅니다. Install Docker우선 Docker를 설치해보겠습니다. 이 사이트에서 각자 자신의 운영체제에 맞게 설치하면 되겠습니다. 1$ docker --version 설치하신 이후 docker가 잘 깔렸는지 확인하기 위해 version 체크를 해보겠습니다. Docker Command Line개인적으로 CLI를 선호하기 때문에 자주 쓰는 명령어를 요약해보겠습니다. CLI보다 GUI Tool을 선호하시는 분은 kitematic을 추천드립니다. 1$ docker --help docker와 관련된 command line 정보를 보여줍니다. 12$ docker pull 'image name'$ docker images pull 명령어는 docker 이미지 내려 받기. Tag에 버전을 따로 적어주지 않으면 최신버전(latest)을 내려받게 됩니다.ex) docker pull ubuntu / docker pull ubuntu:14.04 docker images는 내려받는 docker 이미지 리스트들을 노출시켜줍니다. 12$ docker rm 'container id or name'$ docker rmi 'image id' docker의 container와 image를 삭제시킵니다. 12$ docker run -it --name 'new name' 'image name:tag' /bin/bash$ docker run -d --name 'new name' -p 'host port:container port' 'image name:tag' 새로운 컨테이너를 만들면서 /bin/bash를 실행시키는 명령어입니다. 옵션 i는 interactive의 약자로 사용자가 입출력을 할 수 있는 상태를 만들어줍니다. 옵션 t는 가상 터미널 환경을 emulate 해주는 기능입니다. name 옵션을 주지 않아도 random으로 name이 부여됩니다. /bin/bash 안으로 들어오고 나서 다시 container 밖으로 나오려면 exit를 입력해주시면 됩니다. 이때 container는 종료됩니다. 종료하지 않고 빠져나오고 싶은 경우는 Ctrl + p + q 단축키를 사용합니다. d 옵션 같은 경우는 ubuntu 같은 os 이미지 말고 nginx 같은 어플리케이션을 이미지로 내려받을 경우 입출력이 따로 필요없기 때문에 백그라운드 형태에서 실행시켜주는 역할을 합니다.예) nginx pull로 받고 나서 실행 시킬 경우 : docker run -d –name webserver -p 8000:80 nginx:latest 명령어 실행시킨 후 브라우저에서 localhost:8000으로 접속하면 nginx 서버에 접속하는걸 확인하실 수 있습니다. 12$ docker ps$ docker ps -a docker ps는 현재 실행되고 있는 container 리스트를 보여줍니다. a옵션은 모든 container 리스트(종료된 리스트 포함)까지 보여줍니다. 12$ docker start 'container id or name'$ docker stop 'container id or name' docker container의 실행시켜주고 종료시키는 명령어입니다. 12$ docker attach 'container id or name'$ docker exec -it 'container id or name' /bin/bash 실행되고 있는 container에서 /bin/bash 안으로 들어가서 입출력을 할 수 있게 해줍니다. attach 같은 경우는 명령어 이후 enter키를 한 번 쳐주셔야지 /bin/bash 안으로 접근할 수 있습니다. 12$ docker exec 'container id or name' echo 'hello docker'$ docker exec 'contianer id or name' touch /jason.txt exec는 실행되고 있는 컨테이너 외부에서 컨테이너 내부를 contorl 할 수 있는 명령어입니다. Wrap-upDocker의 기본 개념과 빈번히 사용되는 명령어에 대해서 알아보았습니다. 다음 시간에는 Docker를 활용한 CI(Continuous Integration) 환경 구축을 연습해보도록 하겠습니다. ReferenceDocker 소개초보를 위한 도커 안내서 - 도커란 무엇인가?","categories":[{"name":"Ops","slug":"Ops","permalink":"http://jason0853.github.io/categories/Ops/"},{"name":"Docker","slug":"Ops/Docker","permalink":"http://jason0853.github.io/categories/Ops/Docker/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://jason0853.github.io/tags/Docker/"}]},{"title":"2018 카카오 코딩 테스트 (추석 트래픽)","slug":"2018-kakao-blind-recruitment-round-1-7","date":"2018-03-24T14:01:32.000Z","updated":"2019-05-18T06:10:55.393Z","comments":true,"path":"2018/03/24/2018-kakao-blind-recruitment-round-1-7/","link":"","permalink":"http://jason0853.github.io/2018/03/24/2018-kakao-blind-recruitment-round-1-7/","excerpt":"","text":"드디어 카카오톡 신입 공채 1차 코딩 테스트 마지막 문제입니다. 마지막 문제라 어려울거라 예상했는데 역시나 어려웠습니다.ㅠㅠ 문제를 살짝 읽어보니 로그 데이터를 분석한 후 초당 최대처리량을 구하는 문제입니다. 처리시간은 시작시간과 끝시간을 포함해야합니다. 요청 갯수를 카운트 할때 요청 갯수가 변경되는 순간은 1초(1000ms)입니다. 123456789101112131415161718192021222324252627282930313233343536373839const test = [ [\"2016-09-15 01:00:04.001 2.0s\", \"2016-09-15 01:00:07.000 2s\"], [\"2016-09-15 01:00:04.002 2.0s\", \"2016-09-15 01:00:07.000 2s\"], [\"2016-09-15 20:59:57.421 0.351s\", \"2016-09-15 20:59:58.233 1.181s\", \"2016-09-15 20:59:58.299 0.8s\", \"2016-09-15 20:59:58.688 1.041s\", \"2016-09-15 20:59:59.591 1.412s\", \"2016-09-15 21:00:00.464 1.466s\", \"2016-09-15 21:00:00.741 1.581s\", \"2016-09-15 21:00:00.748 2.31s\", \"2016-09-15 21:00:00.966 0.381s\", \"2016-09-15 21:00:02.066 2.62s\"]];function chuseokTraffic(logs) &#123; const numArr = logs.map(log =&gt; log.match(/\\d+/g).slice(3, 9).map(c =&gt; Number(c))); // 숫자 정규식 / 날짜 제외 slice / number 타입으로 변경 const time = [], lengths = []; let endTime, interval, window = []; for (let arr of numArr) &#123; arr.forEach((elem, idx) =&gt; &#123; switch (idx) &#123; case 0: endTime = 1000 * 60 * 60 * elem; break; case 1: endTime += 1000 * 60 * elem; break; case 2: endTime += 1000 * elem; break; case 3: endTime += elem; break; case 4: interval = elem * 1000; break; case 5: interval = elem ? interval + elem : interval; break; &#125; &#125;); time.push(&#123; startTime: endTime - interval + 1, endTime &#125;); &#125; time.forEach(t =&gt; &#123; window = window.filter(end =&gt; end &gt; t.startTime - 1000); window.push(t.endTime); lengths.push(window.length); &#125;); return Math.max(...lengths);&#125;for (let arr of test) &#123; console.log(chuseokTraffic(arr));&#125;// output: 1, 2, 7 로그데이터를 처리하는데 필요한 부분만 필터링을 해서 numArr 변수에 저장합니다. 1s = 1,000ms, 1m = 60s x 1,000ms, 1h = 60m x 60,000ms를 참고하여 시간을 계산해줍니다. 변수 endTime은 ms로 변환한 값(시간, 분, 초, 밀리세컨드)을 더한 값이며, startTime은 끝시간(endTime)에서 처리시간(interval)을 빼주고 시작시간을 포함해야하므로 1을 더해줍니다.예) 끝시간이 3607000ms이고 처리시간이 2000ms이면 시작시간은 3605001이 되어야합니다. 끝시간이 다음 로그 시작되는 구간에서 1000ms를 뺀 값보다 클 경우 window(초당 최대 처리량이 되는 구간) 배열에 담아 각 구간의 처리량을 lengths배열에 저장해둡니다. forEach 구문이 끝나면 Math.max() 함수를 이용하여 lengths 배열안에 최대값을 구합니다. 확실히 정답률이 낮았습니다. 저 역시도 다른 문제들과 달리 해결 방법이 쉽게 떠오르지 않았습니다. 문제해설을 보시면 o(n log n)으로 풀 수 있는 방법도 있다고 합니다. 다음에 기회가 된다면 이런 방식으로 한 번 고민해서 풀어봐야겠습니다. Wrap-up드디어 마지막 문제까지 다 풀어보았습니다. 블로그에 정리해놨으니 나중에 코드를 리뷰할 때 한결 빠르게 코드를 읽어나갈 수 있을것 같습니다.ㅋㅋ 다음에 시간이 허락된다면 풀었던 문제들을 좀 더 개선된 알고리즘으로 해결해서 공유해볼 수 있도록 노력해보겠습니다. Reference카카오톡 문제 및 해설","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://jason0853.github.io/categories/Algorithm/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://jason0853.github.io/tags/Javascript/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://jason0853.github.io/tags/Algorithm/"}]},{"title":"2018 카카오 코딩 테스트 (프렌즈4블록)","slug":"2018-kakao-blind-recruitment-round-1-6","date":"2018-03-24T13:55:37.000Z","updated":"2019-05-18T06:10:55.392Z","comments":true,"path":"2018/03/24/2018-kakao-blind-recruitment-round-1-6/","link":"","permalink":"http://jason0853.github.io/2018/03/24/2018-kakao-blind-recruitment-round-1-6/","excerpt":"","text":"이번 알고리즘 문제는 그림을 보면 풀고 싶게 만드는 게임 관련 문제입니다. 문제를 한번 살펴보겠습니다. 문제를 읽어보면 같은 모양의 2X2형태 블록이 붙어 있을 경우 지워지면서 위에 남아 있는 블록들은 빈공간으로 이동합니다. 카카오톡에서 이런 게임들은 다들 한번씩은 해보셨을거라 다른 문제보다 한번에 이해가 되셨을겁니다.ㅎㅎ 문제를 풀기 전에 주의해야할 점은 아래와 같은 경우를 고려하시면 되겠습니다. 1234567891011// 삭제 전CCBDEAAADEAAABFCCBBF// 삭제 후CCBDE DE BFCCBBF 위의 경우처럼 2X3 형태로 A문자열이 연결되어 있을 경우 2X2 형태로 바로 삭제하면 안된다는 점입니다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263const test = [ &#123; m: 4, n: 5, board: [\"CCBDE\", \"AAADE\", \"AAABF\", \"CCBBF\"] &#125;, &#123; m: 6, n: 6, board: [\"TTTANT\", \"RRFACC\", \"RRRFCC\", \"TRRRAA\", \"TTMMMF\", \"TMMTTJ\"] &#125;];function friends4Block(m, n, board) &#123; let arr = []; let removedBlockNum = 0; // 각 문자열 배열 만들기 board.forEach((char) =&gt; arr = [...arr, char.split('')]); do &#123; prevBlockNum = removedBlockNum; let arrIdx = []; // 좌표 배열 // 같은 블록 좌표 구하기 for (let i = 0; i &lt; m - 1; i++) &#123; for (let j = 0; j &lt; n - 1; j++) &#123; if (arr[i][j] === arr[i][j+1] &amp;&amp; arr[i][j] === arr[i+1][j] &amp;&amp; arr[i][j] === arr[i+1][j+1]) &#123; arrIdx = [...arrIdx, [i, j], [i, j+1], [i+1, j], [i+1, j+1]]; &#125; &#125; &#125; const filteredStrings = new Set(arrIdx.map(arr =&gt; JSON.stringify(arr))); // string 변경 및 필터링 const toArrIdx = [...filteredStrings].map(str =&gt; JSON.parse(str)); // 배열로 다시 변경 toArrIdx.filter(x =&gt; arr[x[0]][x[1]] = ' '); // 블록 삭제 for (let k = 0; k &lt; m; k++) &#123; // 위에 블록이 밑으로 이동 안했을 경우 대비해서 다시 한번씩 row만큼 스캔 for (let i = 0; i &lt; m; i++) &#123; let temp; for (let j = 0; j &lt; n; j++) &#123; if (arr[i][j] === ' ') &#123; if (!arr[i-1]) continue; // 에러 예외 처리 temp = arr[i-1][j]; arr[i-1][j] = arr[i][j]; arr[i][j] = temp; &#125; &#125; &#125; &#125; removedBlockNum = 0; arr.forEach(x =&gt; removedBlockNum += x.filter(y =&gt; y === ' ').length); &#125; while (prevBlockNum != removedBlockNum); // 이전 삭제 블록 갯수랑 다르면 계속 반복 return removedBlockNum;&#125;for (let obj of test) &#123; console.log(friends4Block(obj.m, obj.n, obj.board));&#125;// output: 14, 15 문자 하나씩을 비교해야하기 때문에 board 배열에 담긴 문자열을 쪼개줍니다. 열(m)과 행(m)만큼 이중 반복문으로 돌리면서 문자열을 체크합니다. 2X2 형태의 문자열이 연결되어 있을 경우 배열 좌표를 arrIdx 배열에 담습니다. 좌표 배열을 담을때 중복되는 좌표값은 new Set()을 사용하여 걸러내고 다시 배열로 변경합니다. filter 메서드를 이용하여 각 좌표값의 블록을 삭제(공백 처리)해줍니다. 3중 loop 같은 경우 위에 남아 있는 블록을 아래로 이동시키기 위함입니다. (성능상 좋은 방식은 아닌것 같습니다. ㅠㅠ) arr 배열에서 공백처리된 부분의 갯수(length)값을 구하고 이전 블록 삭제 갯수랑 현재 블록 삭제된 갯수가 다르면 계속 처음부터 로직을 반복합니다. 반복을 다 마치면 현재 블록 삭제갯수를 리턴시킵니다. 문제해설을 보니 이번 블라인드 채용 문제 중에 코드라인이 가장 길었던 것 같습니다. 아무래도 체크해야할 부분이 많아서 그랬던 것 같습니다. 생각해보니 지금까지 프로그래밍을 하면서 이렇게 많이 반복문을 많이 사용한 적은 처음인 것 같습니다.ㅋㅋ Wrap-up결과적으로 문제는 해결했지만 포스팅에도 중간에 언급했듯이 성능상 안 좋은 코드들이 조금씩 보입니다. 다음 기회에 시간이 된다면 다른 방식으로 풀어서 성능을 개선시켜보겠습니다. 혹시 좀 더 나은 알고리즘으로 푸신 분들은 댓글로 공유부탁드립니다. Reference카카오톡 문제 및 해설","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://jason0853.github.io/categories/Algorithm/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://jason0853.github.io/tags/Javascript/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://jason0853.github.io/tags/Algorithm/"}]},{"title":"2018 카카오 코딩 테스트 (뉴스 클러스터링)","slug":"2018-kakao-blind-recruitment-round-1-5","date":"2018-03-11T07:57:09.000Z","updated":"2019-05-18T06:10:55.392Z","comments":true,"path":"2018/03/11/2018-kakao-blind-recruitment-round-1-5/","link":"","permalink":"http://jason0853.github.io/2018/03/11/2018-kakao-blind-recruitment-round-1-5/","excerpt":"","text":"이번 알고리즘은 중으로 표시되어있지만 생각보다 쉬웠습니다. 긴말 할 필요없이 바로 문제 요약해보고 풀이해보겠습니다. 문제를 읽어보니 자카드 유사도란 낯선 단어가 보입니다. 그런데 겁먹을 필요가 없습니다. 문제안에서 자카드 유사도에 대해 상세히 설명해줍니다. 두집합 사이에 교집합 크기를 합집합 크기로 나눈값이라고 정의합니다. 이해가 바로 되니 길게 설명할 필요가 없습니다.ㅋㅋ 이번엔 입출력 형식을 한번 살펴보고 정리해보겠습니다. 2개의 문자열이 들어옵니다. 각 문자열을 두 글자씩 잘라내야합니다. 두 글자씩 끊을 때 공백, 특수문자, 숫자가 함께 있는 경우는 버립니다. 대소문자 구별은 동일한 걸로 취급합니다. 자카드 유사도 = 교집합 / 합집합 * 65536 교집합이 공집합일 경우 1로 간주합니다. 소수점 이하는 버리고 정수부분만 출력합니다.다중집합일경우 교집합은 min(최소값) 합집합은 max(최대값)으로 계산을 해야합니다. 제가 초반에 이 부분을 고려하지 않고 코드를 작성하다 실수를 했었습니다.ㅠㅠ 이제 코드를 공개해보겠습니다. 12345678910111213141516171819202122232425262728293031323334353637383940414243const test = [ &#123; str1: 'FRANCE', str2: 'french' &#125;, &#123; str1: 'handshake', str2: 'shake hands' &#125;, &#123; str1: 'aa1+aa2', str2: 'AAAA12' &#125;, &#123; str1: 'E=M*C^2', str2: 'e=m*c^2' &#125;];function newsClustering(str1, str2) &#123; const arr = []; for (let i = 0; i &lt; arguments.length; i++) &#123; const str = arguments[i].toLowerCase(); arr[i] = []; for (let j = 0, len = str.length - 1; j &lt; len; j++) &#123; let reg = str.substr(j, 2).match(/^[a-z]*$/); if (reg) arr[i].push(reg.input); &#125; &#125; const set = new Set([...arr[0], ...arr[1]]); let size1, size2, intsecNum = 0, unionNum = 0; set.forEach(val =&gt; &#123; size1 = arr[0].filter(char =&gt; char === val).length; size2 = arr[1].filter(char =&gt; char === val).length; intsecNum += Math.min(size1, size2); unionNum += Math.max(size1, size2); &#125;); if (!intsecNum) intsecNum = 1; if (!unionNum) unionNum = 1; return Math.floor(intsecNum / unionNum * 65536);&#125;for (let obj of test) &#123; console.log(newsClustering(obj.str1, obj.str2));&#125;// output: 16384, 65536, 43690, 65536 파라미터로 전달받은 각 문자열(str1,str2)을 toLowerCase() 메서드를 이용하여 소문자로 만들어주었습니다. 대문자로 만들어도 무방합니다. 변수 reg는 문자열을 두 글자씩 끊은 다음 정규식으로 영문자열일 경우 배열 형태로 반환되어 저장됩니다. 만약 영문자 이외의 문자나 공백이 함께 오는 경우는 null값으로 반환되어 저장됩니다. 그렇다면 배열 값이 존재할 때만 빈 배열에 push하면 됩니다. Set 객체를 이용하여 두 배열에서 존재하고 있는 유일한 값만을 저장합니다. set이란 변수에 담긴 배열을 이용하여 두 배열(arr[0], arr[1]) 안에 일치하는 문자열 갯수를 구합니다. size1, size2 두 변수를 Math.min(), Math.min()를 이용하여 최소값(교집합 갯수), 최대값(합집합 갯수)을 구합니다. 교집합과 합집합이 0일 경우도 있으므로 예외처리(1) 값을 처리해줍니다. Math.floor(intSecNum / unionNum * 65536) 위 문제에서 말한대로 자카드 유사도 식에 65536 곱해서 소숫점 이하는 버리고 정수부분만 반환시킵니다. 문제 해설을 보니 정답률이 지난번 셔틀버스보다 높게 나왔습니다. 문제랑 입출력 예제만 꼼꼼히 잘 살펴본다면 실수하지 않고 다들 푸실 수 있을 것 같습니다. Wrap-up개인적으로 지금까지 풀어본 알고리즘 문제들 중에 가장 쉬웠던 것 같습니다. 풀기 전에 머릿속으로 ‘이런 방식으로 짜야지’ 생각하고 풀었는데 술술 잘 풀려서 기분이 좋았습니다. 사실 초반에 빨리 푸는 바람에 실수했었습니다.ㅠㅠ 그럼 다음 포스팅에서 찾아뵙겠습니다. Reference카카오톡 문제 및 해설","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://jason0853.github.io/categories/Algorithm/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://jason0853.github.io/tags/Javascript/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://jason0853.github.io/tags/Algorithm/"}]},{"title":"2018 카카오 코딩 테스트 (셔틀버스)","slug":"2018-kakao-blind-recruitment-round-1-4","date":"2018-03-02T14:15:27.000Z","updated":"2019-05-18T06:10:55.392Z","comments":true,"path":"2018/03/02/2018-kakao-blind-recruitment-round-1-4/","link":"","permalink":"http://jason0853.github.io/2018/03/02/2018-kakao-blind-recruitment-round-1-4/","excerpt":"","text":"이번 문제는 정말 어려웠었습니다. 난이도도 중으로 표시되어 있어서 쫄았었는데 진짜 푸는데 몇 일 걸렸습니다. 예상컨대 다음 문제부터는 못 풀지도 모르겠습니다. ㅠㅠ 하이튼 같이 한번 제가 푼 방식을 공유해보겠습니다. 셔틀의 시작 시간 - 09:00 n회 t분 간격으로 도착하므로 예를 들어 5회 10분 간격이면 09:00, 09:10, 09:20, 09:30, 09:40 이렇게 셔틀버스가 운영됩니다. 셔틀버스 도착 시간에 딱 맞춰서 줄을 서도 빈자리가 있으면 탈 수 있습니다. 같은 시각에 온 사람일경우 주인공 콘은 맨 뒤에 서야합니다. 입출력 형식 및 예제를 다 살펴보았습니다. 제일 늦은 시각을 출력해보겠습니다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748const test = [ &#123; n: 1, t: 1, m: 5, timetable: [\"08:00\", \"08:01\", \"08:02\", \"08:03\"] &#125;, &#123; n: 2, t: 10, m: 2, timetable: [\"09:10\", \"09:09\", \"08:00\"] &#125;, &#123; n: 2, t: 1, m: 2, timetable: [\"09:00\", \"09:00\", \"09:00\", \"09:00\"] &#125;, &#123; n: 1, t: 1, m: 5, timetable: [\"00:01\", \"00:01\", \"00:01\", \"00:01\", \"00:01\"] &#125;, &#123; n: 1, t: 1, m: 1, timetable: [\"23:59\"] &#125;, &#123; n: 10, t: 60, m: 45, timetable: [\"23:59\", \"23:59\", \"23:59\", \"23:59\", \"23:59\", \"23:59\", \"23:59\", \"23:59\", \"23:59\", \"23:59\", \"23:59\", \"23:59\", \"23:59\", \"23:59\", \"23:59\", \"23:59\"] &#125;,];function shuttleBus(n, t, m, timetable) &#123; function calculateTime(str) &#123; const hour = Number(str.substr(0, 2)) * 60, min = Number(str.substr(3, 2)) * 1; return hour + min; &#125; function formatTime(num) &#123; const hh = String(Math.floor(num / 60)).padStart(2, '0'), mm = String(num % 60).padStart(2, '0'); return `$&#123;hh&#125;:$&#123;mm&#125;`; &#125; const startTime = calculateTime('09:00'), lastTime = startTime + t * (n - 1), crewTime = timetable.map(calculateTime).filter(time =&gt; time &lt;= lastTime).sort(); for (let i = 0; i &lt; n; i++) &#123; const shuttleTime = startTime + i * t, crewNum = crewTime.filter(time =&gt; time &lt;= shuttleTime).length; if (i === n - 1) &#123; if (crewNum &lt; m) return formatTime(lastTime); return formatTime(crewTime[m - 1] - 1); &#125; else &#123; if (crewNum &gt; m) &#123; crewTime.splice(0, m); &#125; else &#123; crewTime.splice(0, crewNum); &#125; &#125; &#125;&#125;for (let obj of test) &#123; console.log(shuttleBus(obj.n, obj.t, obj.m, obj.timetable));&#125;// output: 09:00, 09:09, 08:59, 00:00, 09:00, 18:00 calculateTime 메서드는 string 타입으로 된 시간 표시를 number 타입으로 계산하는 함수입니다.예) 시간 X 60 / 분 X 1 - 09:01 - 541 formatTime 메서드는 calculateTime와 반대로 다시 string 타입으로 시간 표시를 해주는 함수힙니다. 마지막 값을 리턴해줄때 사용합니다. startTime + t * (n - 1) 계산값은 버스의 마지막 시간을 구하게 됩니다.예) 셔틀버스 시작 시간 + 시간 간격 X (셔틀버스 횟수 - 1) timetable.map(calculateTime) 배열 값을 전부 time 계산값으로 바꿔줍니다. timetable.filter(time =&gt; time &lt;= lastTime) 셔틀버스의 마지막 시간보다 늦게 오면 탈 수 없으므로 필터링 해줍니다. timetable.sort() 배열을 오름차순으로 정렬해줍니다. n 버스 횟수만큼 for loop를 돌려서 각각의 shuttleTime(셔틀버스 도착시간)과 crewNum(셔틀버스 도착시간 전에 온 크루들 몇 명)를 구합니다. splice 함수를 통해 셔틀버스 도착시간 전에 온 크루들이 버스 사이즈보다 더 많을 경우 다 타지 못하므로 사이즈(m)만큼 배열을 잘라줍니다. if (i === n - 1) 조건문을 통해 마지막 loop를 돌때 crewTime의 남아있는 배열 시간값을 알수 있습니다. 이 값들을 통해 버스를 탈 수 있는 가장 늦은 시각을 구할 수 있습니다. 문제 해설을 읽어보니 역시나 어려운 문제였던것 같습니다. 정답률이 26.79%네요. 이번 문제 같은 경우 마지막 버스 시간까지 꼼꼼히 고려하지 않으면 실수할 경우가 많았을 것 같습니다. Wrap-up이 문제 같은 경우는 같이 스터디하는 친구가 힌트를 주면서 풀었기 때문에 그나마 접근해서 풀 수 있었습니다. 결국 풀다보니 코드도 동일해져버렸지만 이런 문제를 풀면서 다양하게 접근하는 방식을 익힐 수 있어서 좋은 시간이었던 것 같습니다. 몇 일 걸렸지만 ㅠㅠ 혹시 이거 말고 다른 로직으로 푸신분 공유해주시면 정말 감사하겠습니다. Reference카카오톡 문제 및 해설","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://jason0853.github.io/categories/Algorithm/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://jason0853.github.io/tags/Javascript/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://jason0853.github.io/tags/Algorithm/"}]},{"title":"Typescript Features","slug":"Typescript-Features","date":"2018-02-28T19:34:04.000Z","updated":"2019-05-18T06:10:55.391Z","comments":true,"path":"2018/03/01/Typescript-Features/","link":"","permalink":"http://jason0853.github.io/2018/03/01/Typescript-Features/","excerpt":"","text":"지난 포스팅에 타입스크립트를 하기 위한 환경을 구축했었습니다. 그럼 본격적으로 타입스크립트의 특징에 대해서 하나하나 실습해보겠습니다. # Checking Type자바스크립트는 동적타입 언어이기 때문에 기존 타입에 다른 타입을 대입해도 에러가 나지 않았습니다. 하지만 타입스크립트는 다른 언어(Java)처럼 타입을 시스템을 도입하여 Type 선언을 엄격하게 합니다.만약 string 타입 변수에 number를 넣으면 아래처럼 에러가 발생합니다. 123456789let test1: string = 'Test';test1 = 3; // [ts] Type '3' is not assignable to type 'string'.let test2;test2 = 'Jaesung';test2 = 33;let test3 = 'Jaesung Lee';test3 = false; // [ts] Type 'false' is not assignable to type 'string'. let test1: string 코드를 보면 콜론(:) 뒤에 string이라고 타입을 명시해주었습니다. 즉, string 타입 이외에 다른 타입의 값이 할당되면은 에러를 발생하게 됩니다. test2 변수는 선언할 때 값을 할당하지 않았습니다. 이런 경우는 let test2: any; 타입으로 명시해준거랑 같습니다. test3 변수는 타입이 선언되지 않았지만 초기값이 string 타입으로 값이 할당되었기 때문에 할당 과정에서 타입이 string으로 결정됩니다. 그렇기 때문에 다른 타입의 값이 재할당되면 에러가 발생하게 됩니다. 123456789101112131415161718192021222324252627282930313233// string, number, booleanlet pName: string = 'Jason';let pAge: number = 33;let isJob: boolean = true;let profile: string = `Name: $&#123;pName&#125;, Age: $&#123;pAge&#125;, Job: $&#123;isJob&#125;`;// anylet val: any = 'test';val = 33;val = false;// objectconst person: object = &#123;&#125;;// arraylet info: any[] = ['Jason Lee', 33, true];let friends: Array&lt;string&gt; = ['Jason', 'Jane', 'Lilly'];// Tuplelet player: [string, number];player = ['Kobe', 8];// Enumenum Player &#123;Kobe = 8, Tmac = 1, Kyrie = 11&#125;;let p: Player = Player.Kyrie;let playerName: string = Player[8];console.log(p); // 0console.log(playerName); // Kobefunction test(): void &#123; console.log('test'); &#125; any 타입은 어떠한 타입의 값도 들어올 수 있습니다. 하지만 실무에서는 any 타입을 지양하는 것을 권고합니다. array 타입을 지정할 때는 두 가지 방식이 있습니다. 두번째 방식을 generic array type이라고 합니다. Tuple이란 array type의 고정된 수의 유형이면서 동일한 타입의 배열이 아닐 때 사용할 수 있습니다. Enum이란 C#과 같은 언어에서처럼 열거형은 숫자값 집합에 더 친숙한 이름을 지정하는 방법입니다. 함수에 void가 선언되어 있을 경우 리턴값이 없어야합니다. # function type함수에 타입을 명시함으로써 argument나 return 타입이 어떤 형태인지 쉽게 알 수 있습니다. 123456789101112function sum(a: number, b: number): number &#123; return a + b;&#125;function show(): string &#123; return 'Calculate';&#125;let myCal: (x: number, y: number) =&gt; number;myCal = sum;console.log(myCal(1, 2)); // 3myCal = show; // [ts] Type '() =&gt; string' is not assignable to type '(x: number, y: number) =&gt; number'. Type 'string' is not assignable to type 'number'. myCal = show 코드에서 에러가 난 이유는 서로 타입이 다르기 때문입니다. myCal은 인자와 return 타입이 함께 지정되어 있으며 show는 return을 string으로 받는 함수 타입입니다. # Object type123456789let info: &#123; name: string; age: number; job: boolean; &#125;;info = &#123; name: 'Jaesung', age: 34, job: true &#125;;// custom typetype profile = &#123; name: string; age: number; job: boolean; &#125;;let p1: profile = &#123; name: 'Jaesung', age: 34, job: true &#125;;let p2: profile = &#123; name: 'Jimmy', age: 19, job: false &#125;;let p3: profile = &#123; name: 'Dennis', age: 22, job: true &#125;; p1, p2, p3는 동일한 타입이지만 변수 info처럼 개별적으로 타입을 선언해주는 것은 좀 별로인것 같습니다. 이때 type과 함께 custom type을 명시해줍니다. # Union Type하나 이상의 어떤 타입을 지정하는 방식을 Union Type이라고 합니다. 1234let players: string[] | number[] | boolean[] = ['Kobe Bryant', 'Tracy Mcgrady'];players = [8, 1];players = [true, false]; any타입을 쓰면 간단하지만 Union Type(string[] | number[] | boolean[])을 쓰는 것을 권장합니다. # classTypesciprt의 클래스는 ES6의 class와 사용법이 다르니 한번 자세히 다뤄보겠습니다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758class Person &#123; public readonly name: string; private age: number; protected job: boolean; static hobby: string[] = ['Basketball', 'Swimming', 'Jit Jitsu']; static word: string = 'Hi, How are you?'; constructor(name: string, age: number, job: boolean) &#123; this.name = name; this.age = age; this.job = job; &#125; setAge(newAge: number): void &#123; this.age = newAge; &#125; getAge(): number &#123; return this.age; &#125; move(text: string): void &#123; console.log(text); &#125; static greet(): string &#123; return this.word; &#125;&#125;class Student extends Person &#123; constructor(name: string, age: number, job: boolean) &#123; super(name, age, job ); super.move('I can walk.'); &#125; change(isJob: boolean): void &#123; this.job = isJob; &#125; isJob(): boolean &#123; return this.job; &#125;&#125;const p1:Person = new Person('Jason', 33, true);const p2:Student = new Student('Jane', 18, false);// p1.name = 'Jason Lee' // [ts] Cannot assign to 'name' because it is a constant or a read-only property.console.log(p1.name); // Jason// p2.setAge(19);// console.log(p2.getAge()); // 19console.log(p2.isJob()); // falseconsole.log(Person.greet()); // Hi, How are you?console.log(Person.hobby); // [\"Basketball\", \"Swimming\", \"Jit Jitsu\"] public - 클래스, 서브클래스, 인스턴스 어디에서도 접근 가능. private - 클래스 내부 이외의 서브클래스나 인스턴스에서는 접근 불가능. protected - 클래스 내부와 서브클래스 내부에서만 접근 가능. 인스턴스 접근 불가능. readonly - 읽기 전용 propery. static - 클래스의 인스턴스로 호출하지 않고 접근할 수 있음. 인스턴스 접근 불가능.static greet()메서드 안에 있는 this는 인스턴스가 아닌 클래스 person을 가르킵니다. 12345678910111213141516171819202122232425262728abstract class Car &#123; constructor(public name: string) &#123; &#125; abstract brand(): string; move(): void &#123; console.log('test car'); &#125;&#125;class Genesis extends Car &#123; constructor() &#123; super('Genesis') &#125; brand() &#123; return 'Hyundai' &#125;&#125;const g = new Genesis();g.move(); // test carconsole.log(g.name); // Genesisconsole.log(g.brand()); // Hyundai 추상클래스(abstract class)는 오직 상속만 가능하며 추상 메소드는 상속하는 클래스에 반드시 구현이 되어 있어야합니다. # interface인터페이스(interface)는 custom type과 거의 비슷하지만 몇 가지 효율적인 면이 있습니다. 클래스와 상속에서 유용하게 사용할 수 있습니다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647interface Human &#123; readonly id: number; name: string; alive: boolean; age?: number; say: (arg: string) =&gt; string;&#125;let person: Human;person = &#123;id: 111, name: 'Jason', alive: true, say: (lang: string) =&gt; lang&#125;;function getName(info: Human): void &#123; console.log(info.name)&#125;getName(person); // Jasonconsole.log(person.say('Korean')); // Koreanclass Student implements Human &#123; constructor( public id: number, public name: string, public alive: boolean ) &#123;&#125; say(lang: string): string &#123; return lang &#125;&#125;const p = new Student(123, '18', true);console.log(p.say('English')); // Englishinterface Gender &#123; gender: string;&#125;interface Foreigner extends Human, Gender &#123; nation: string;&#125;let engineer: Foreigner = &#123;id: 111, name: 'Jason', alive: true, say: (lang: string) =&gt; lang, nation: 'Korea', gender: 'M'&#125;// 빈 걕체 초기화// let engineer = &lt;Foreigner&gt;&#123;&#125;; ? Optional Property입니다. 인터페이스에 기술한 프로퍼티와 메소드가 반드시 구현되어야 합니다. 하지만 선택적 프로퍼티(?)를 붙이면 생략해도 무방합니다. 클래스랑 같이 쓸때 메소드 내부를 반드시 구현해야합니다. 여러 인터페이스 상속이 가능합니다. engineer 변수를 초기화하지 않고 비어있는 객체로 설정하고 싶다면 Generic 문법을 사용하여 빈 객체로 둔 상태에서 property를 추가해줄수 있습니다. # type alias VS interface앞에 살짝 다뤘던 type alias와 interface까지 공부해보았습니다. 그런데 여기서 궁금한 점이 하나 생겼습니다. interface와 type alias의 차이는 무엇일까요? 1234567891011121314151617interface Profile &#123; name: string;&#125;interface Profile &#123; age: number;&#125;interface Info extends Profile &#123; isJob: boolean;&#125;const person: Info = &#123; name: 'Jason', age: 33, isJob: true,&#125;; 인터페이스는 같은 인터페이스에 property를 추가해줄 수 있고 extends 키워드를 통하여 확장할 수 있습니다. implements 키워드를 통하여 인터페이스를 구현할 수도 있습니다. 반면에 type alias는 어떨까요? 123456789101112131415161718type Job = string | boolean;type Profile = &#123; name: string; age: number;&#125;type Work = &#123; job: Job&#125;type Info = (Profile &amp; Work) | null;const person: Info = &#123; name: 'Jason', age: 33, job: true&#125;; type alias는 인터페이스와 달리 Union Type을 지정할 수도 있고 다른 type alias랑 결합해서 다른 이름을 지정할 수 있습니다. 12345678910111213141516interface Profile &#123; name: string; age: number;&#125;interface Work &#123; job: string | boolean;&#125;type Info = (Profile &amp; Work) | null;const person: Info = &#123; name: 'Jason', age: 33, job: 'true'&#125;; 위와 같이 interface와 type alias를 혼용해서 사용할 수도 있습니다. # Generic제네릭(Generic)은 위에서 배운 타입 선언과 달리 미리 선언을 명시하지 않고 생성한 뒤에 타입이 정해집니다. 또한 타입도 여러가지 타입이 올 수 있습니다. 123456789101112131415161718192021222324// function test1(arg: number): number &#123;// return arg;// &#125;// function test2(arg: string): string &#123;// return arg;// &#125;// function test3(arg: boolean): boolean &#123;// return arg;// &#125;function test&lt;T&gt;(arg: T): T &#123; return arg;&#125;let answer = test&lt;string&gt;('Generic');console.log(answer); // Genericlet myAnswer: &lt;T&gt;(arg: T) =&gt; T = test;// let myAnswer2: &#123; &lt;T&gt;(arg: T): T &#125; = test; // 변수 myAnswer와 같음console.log(myAnswer('Generic')); // Generic 주석친 부분을 보시면 같은 함수인데 타입만 다를뿐 안에 구현되는 내용은 같습니다. 이럴때 좀 더 간편하게 쓸 수 있는 것이 Generic입니다. 선언 시점에 타입을 명시하는 것이 아니라 생성 시점, 즉 test함수가 실행되면서 타입이 string으로 정해집니다. 12345678910111213141516171819class Person&lt;T, U&gt; &#123; name: T; age: U; constructor(name: T, age: U) &#123; this.name = name; this.age = age; &#125; getName(): T &#123; return this.name; &#125; getAge(): U &#123; return this.age; &#125;&#125;const p = new Person&lt;string, number&gt;('Jaesung', 33); Generic Class 같은 경우 기본 구조는 위와 같습니다. Wrap-up지금까지 간략하게 타입스크립트의 특징에 대해서 알아보았습니다. 자바스크립트만 하다가 타입을 명시하면서 코딩을 하니까 몬가 어색했지만 프로젝트를 진행할 때 좀 더 안정적으로 개발할 수 있을것 같다는 생각이 들었습니다. 특히 인터페이스나 타입이 지정되어 있기 때문에 새로운 팀원이 투입될 시 빠르게 코드 분석을 할 수 있을 것 같습니다. 타입스크립트를 계속 관심만 가지고 지켜보다가 비로소 이번 포스팅으로 인해 첫걸음을 뗀 것 같습니다. 이번에 다루지 못하고 지나간 부분들은 다음 포스팅때 좀 더 공부해서 공유해보도록 하겠습니다. Reference타입스크립트 공식 홈페이지타입 선언과 정적 타이핑type과 interface 차이는 무엇인가?","categories":[{"name":"Front-end","slug":"Front-end","permalink":"http://jason0853.github.io/categories/Front-end/"},{"name":"Typescript","slug":"Front-end/Typescript","permalink":"http://jason0853.github.io/categories/Front-end/Typescript/"}],"tags":[{"name":"Typescript","slug":"Typescript","permalink":"http://jason0853.github.io/tags/Typescript/"},{"name":"tsconfig","slug":"tsconfig","permalink":"http://jason0853.github.io/tags/tsconfig/"}]},{"title":"Typescript Basic and Configuration","slug":"Typescript-Basic-and-Configuration","date":"2018-02-27T04:25:40.000Z","updated":"2019-05-18T06:10:55.391Z","comments":true,"path":"2018/02/27/Typescript-Basic-and-Configuration/","link":"","permalink":"http://jason0853.github.io/2018/02/27/Typescript-Basic-and-Configuration/","excerpt":"","text":"타입스크립트는 Microsoft에서 만든 정적 타입언어이며, 자바스크립트의 한계를 보완해줄 수 있습니다. 개인적으로 가장 큰 장점은 자바스크립트(ES5, ES6)와 타입스크립트 문법을 공존해서 쓸 수 있는 것이라고 생각합니다. 한 마디로 Typescript는 Javascript의 super set이라고 정의하는데 자바스크립트 개발자들에게는 반가운 소식일 것 같습니다. 이번 포스팅은 타입스크립트를 시작하는 방법에 대해서 알아보겠습니다. # Getting started with Typescript우선 typescript를 install하고 제대로 설치되었는지 확인해보겠습니다. 그리고 Microsoft사에서 제공하는 에디터인 vscode를 설치해서 실습을 진행하겠습니다. 12$ npm install -g typesciprt$ tsc -v 간단하게 test.ts 파일을 하나 만들어서 js 파일로 compile 해보겠습니다. test.ts12345function test(lang: string): string &#123; return lang;&#125;console.log(test('Typescript')); 1$ tsc test.ts test.js1234function test(lang) &#123; return lang;&#125;console.log(test('Typescript')); node로 test.js를 실행시켜보겠습니다. 12$ node test.jsTypescript ‘Typesciprt’가 log에 출력됩니다. 간단히 ts 파일을 만들고 실행까지 시켜보았습니다. 이번에는 tsc 몇가지 명령어에 대해서 정리해보겠습니다. 1234$ tsc *.ts$ tsc 'filename' --watch$ tsc 'filename' -t 'target'$ tsc --init asterisk(*)을 사용하여 모든 ts 파일을 js 파일로 complie합니다. watch 옵션은 해당 파일을 계속 감지하여 js 파일로 변경시켜줍니다. t 옵션은 target의 약자로 타입스크립트의 기본 compile system은 ES3로 target이 정해져 있습니다. 만약 ES5로 바꾸고 싶다면 아래와 같이 명령어를 실행시켜주세요.예) tsc test.ts -t ES5 tsconfig.json 파일을 생성시켜줍니다. 그 이후 tsc 명령어를 치면 모든 타입스크립트 파일이 자바스크립트 파일로 compile 됩니다. # tsconfig.json타입스크립트로 프로젝트를 시작할 때 tsconfig.json에 다양한 옵션을 정의하여 환경설정을 기술할 수 있습니다. 어떤 옵션들이 있는지 한 번 살펴보겠습니다. baseUrl : 기본 url 설정 rootDir : root directory 설정 (outDir 옵션과 함께 사용) outDir : 결과 파일을 저장할 directory 지정 target : target 변경 module : module mode 지정 removeComments : 주석 삭제 strict : 모두 엄격하게 type checking(noImplicitAny, noImplicitThis, alwaysStrict, strictNullChecks, strictFunctionTypes, strictPropertyInitialization) sourceMap : map 파일 생성 (vscode에서 디버깅할려면 true로 변경해야함) pretty : error message colorfully 출력 noEmitOnError : compile 대상 리스트 include : error 발생시 결과 파일 저장 안함 exclude : compile 대상 제외 리스트 lib : 라이브러리 목록 이 옵션 이외에도 다양한 옵션들이 많이 있습니다. 여기를 참고해주세요. # Debugvscode에서 디버깅하는 방법을 한번 알아보겠습니다. 아래처럼 폴더 구조와 파일을 만들어주고 코드를 넣어주세요. tsconfig.json파일에는 위 코드를 copy/paste 해주세요. 123- src |-test.tstsconfig.json 12345function debug(text: string): string &#123; return text;&#125;console.log(debug('Debugging')); CMD + Shift + B 를 누르면 tsc: watch - tsconfig.json을 선택합니다. 그럼 코드가 바뀔때마다 compile 작업을 하면서 dist 폴더에 test.js 파일과 test.js.map 파일이 생성됩니다.이제 breakpoint를 걸고 디버깅을 해보겠습니다. 코드 넘버 라인 왼쪽에 breakpoint(중단점)을 걸고 vscode 왼쪽 네번째 디버깅 버튼을 선택합니다. 왼쪽 사이드바가 바뀌면 디버그 버튼 클릭하고 Node.js를 선택합니다. 디버깅이 시작됩니다. DEBUG CONSOLE에 Debugging이 출력됩니다. Issue타입스크립트를 공부하다보니 에러가 중간중간 생기는 바람에 공부하는 흐름이 끊긴 적이 간혹 있었습니다. 아래는 문제해결 방법입니다. cannot find name ‘console’.1$ yarn add --dev @types/node Cannot redeclare block-scoped variable ‘name’.1234567&#123; \"compilerOptions\": &#123; \"lib\": [ \"es2015\" ] &#125;&#125; Unknown compiler option ‘strictPropertyInitialization’.1$ yarn add --dev typescript@latest Wrap-up이제 typescript를 공부하기 위한 최소한의 개발환경을 셋팅해보았습니다. 다음 포스팅부터 본격적으로 타입스크립트의 문법 및 기능들을 살펴보겠습니다. ReferenceVisual Studio Code에서의 TypeScript 개발 환경 구축","categories":[{"name":"Front-end","slug":"Front-end","permalink":"http://jason0853.github.io/categories/Front-end/"},{"name":"Typescript","slug":"Front-end/Typescript","permalink":"http://jason0853.github.io/categories/Front-end/Typescript/"}],"tags":[{"name":"Typescript","slug":"Typescript","permalink":"http://jason0853.github.io/tags/Typescript/"},{"name":"tsconfig","slug":"tsconfig","permalink":"http://jason0853.github.io/tags/tsconfig/"}]},{"title":"ES6 Features","slug":"ES6-Features","date":"2018-02-20T08:57:20.000Z","updated":"2019-05-18T06:10:55.391Z","comments":true,"path":"2018/02/20/ES6-Features/","link":"","permalink":"http://jason0853.github.io/2018/02/20/ES6-Features/","excerpt":"","text":"자바스크립트 관련 포스팅을 하면서 ES6 문법을 간혹 쓴 경우가 있었는데 이번 기회에 ES6 문법 기능을 한번 정리해보겠습니다. 물론 기존 Vanilla Javascript(ES5)도 우수하지만 ES6 문법을 혼용해서 쓰면 좀 더 간결하게 코드를 작성할 수 있고 다른 언어에서 지원되는 클래스(물론 무늬만)나 상수도 지원받을 수 있습니다. # var, let, const기본적으로 var는 function-scope이고 let, const는 block-scope입니다. 1234567891011121314151617181920// ES5var i = 1000;(function() &#123; // var i 호이스팅(hoisting) for (i = 0; i &lt; 3; i++) &#123; console.log(i); // 0, 1, 2 &#125; var i;&#125;)();console.log('after loop', i); // after loop 1000// ES6var i = 1000;for (let i = 0; i &lt; 3; i++) &#123; console.log(i); // 0, 1, 2&#125;console.log('after loop', i); // after loop 1000 ES5 문법을 보면 함수 안에 var i;는 나중에 선언되었지만 에러가 나지 않고 호이스팅(hoisting)이 일어나면서 함수 최상단으로 끌어올려집니다. 위에서 언급한대로 var는 함수 스코프 단위로 범위가 정해져있기 때문에 loop가 끝나고 나서는 console.log(‘after loop’, i);는 함수 바깥에 선언된 변수 i에 접근하게 됩니다. ES6 문법에서는 ES5와 달리 블록 단위로 변수 범위가 정해져있습니다. ES5처럼 굳이 함수를 만들지 않아도 위와 똑같은 결과물이 나옵니다. 하지만 var처럼 변수를 나중에 선언하게 되면은 호이스팅은 되지만 Uncaught ReferenceError: i is not defined 에러가 발생할 것입니다.. 그 이유는 let은 항상 선언이 된 뒤에 값이 할당되어야 한다는 전제 조건이 있기 때문입니다. 123456let name;name = 'Jaesung';name = 'Jason';console.log(name);const age; // Uncaught SyntaxError: Missing initializer in const declaration let는 선언은 먼저 하고 값은 나중에 할당해도 상관없습니다. const는 항상 선언과 값을 함께 할당해야 에러가 발생하지 않습니다. 12const age = 33;age = 34; // Uncaught TypeError: Assignment to constant variable. const는 재할당 불가입니다. 1234567891011const person = &#123; name: 'Jaesung', age: 33&#125;;person.name = 'Jason';person.job = true;person = &#123; // Uncaught TypeError: Assignment to constant variable. job: true&#125;; const는 객체의 property 값을 변경 및 새로운 property 값을 추가할 수 있지만 재할당 불가입니다. 프로그래밍을 할 때 변경 가능한 상태(mutable state)를 최소화하는 습관을 들이는 것이 중요합니다. 왜냐하면 에러가 예상치 못한 곳에서 발생하기 때문에 디버깅하기가 너무 어렵기 때문입니다. 최근 자바스크립트에서는 var를 지양하고 let과 const를 지향하라고 권장합니다. # Destructuring / Template Literals / Spread OperatorDestructuring은 비구조화 할당이라고 하며 객체와 배열을 변수로 변환해주는 기능입니다.Template Literals은 ${} 문법을 제공하여 좀 더 편리하게 문자열을 처리할 수 있는 기능입니다.Spread Operator은 전개 연산자라 하며 2개 이상의 인자, 요소, 변수들을 확장시키는 기능입니다. 12345678910const movie = &#123; title: 'Friends with Benefits', genre: 'Romance'&#125;;const &#123; title: tit, genre: gen, rating = 'R' &#125; = movie;console.log(tit); // Friends with Benefitsconsole.log(gen); // Romanceconsole.log(rating); // R 위 코드 6번째 줄을 보면 객체의 속성을 별개의 변수로 추출하여 새로운 변수(title: tit, genre: gen) 및 default 값(rating = ‘R’)을 제공할 수 있습니다. 1234567891011121314151617181920showMovie(&#123; title: 'Jason Bourne', genre: 'Action'&#125;);// ES5function showMovie(opt) &#123; var tit = opt.title, genre = opt.genre, rating = opt.rating || 'R'; console.log('title: ' + opt.title + ', genre: ' + opt.genre + ', rating: ' + rating);&#125;// ES6function showMovie(&#123; title: tit, genre, rating = 'R' &#125;) &#123; console.log(`title: $&#123;tit&#125;, genre: $&#123;genre&#125;, rating: $&#123;rating&#125;`);&#125;// Output// title: Jason Bourne, genre: Action, rating: R ES6 문법을 적용하니 확실히 코드량이 줄어들었습니다. 특히 Template Literals 문법을 사용하니 ES5보다 문자열 처리가 간결해졌습니다. 12345678910111213141516171819202122const numbers = [1, 2, 3, 4, 5];const [first, ...rest] = numbers;console.log(first); // 1console.log(...rest); // 2 3 4 5const Person = function(name, age, job) &#123; this.name = name; this.age = age; this.job = job;&#125;;Person.prototype.log = function() &#123; console.log(`name: $&#123;this.name&#125;, age: $&#123;this.age&#125;, job: $&#123;this.job&#125;`);&#125;const subInfo = [33, 'Front-end Engineer'];const info = ['jason', ...subInfo];// info.push(...subInfo);const p1 = new Person(...info);p1.log(); // name: Jason, age: 33, job: Front-end Engineer … 전개 연산자 문법입니다. 전개 연산자를 이용했기 때문에 굳이 push() 함수 및 파라미터 전달을 하나하나 할 필요가 없어졌습니다. 이렇게 3가지 새로운 문법에 대해서 간략히 살펴보았는데 코드량이 상당히 줄어들어 가독성이 향상되는 장점이 있는 것 같습니다. # Arrow FunctionArrow Function(화살표 함수)는 간결하고 this가 기존의 ES5와 다르게 작동합니다. 또한 생성자 함수로는 적합하지 않습니다. 123456789101112131415function Movie(title) &#123; this.title = title; // ES5 setTimeout(function() &#123; console.log(this.title); // Jason Bourne &#125;.bind(this), 1000); // ES6 setTimeout(() =&gt; &#123; console.log(this.title); // Jason Bourne &#125;, 1000);&#125;const m1 = new Movie('Jason Bourne'); ES5 문법에서 bind(this)를 하지 않으면 this는 window 객체를 가리킵니다. ES6 문법에서는 this가 새로운 target으로 바인딩되지 않고 Movie 객체를 정확히 참조합니다. 1234567891011121314151617181920212223242526272829303132const playerInfo = [ &#123; position: 'PG', name: 'Kyrie Irving', score: 20, retired: false &#125;, &#123; position: 'SG', name: 'Kobe Bryant', score: 30, retired: true &#125;, &#123; position: 'SG', name: 'Tracy Mcgrady', score: 25, retired: true &#125;, &#123; position: 'PF', name: 'Aaron Gordon', score: 20, retired: false &#125;, &#123; position: 'PF', name: 'Tim Duncan', score: 23, retired: true &#125;,];// ES5const sgTotalScore = playerInfo .filter(function(info) &#123; return info.retired === true; &#125;) .filter(function(info) &#123; return info.position === 'SG'; &#125;) .map(function(info) &#123; return info.score; &#125;) .reduce(function(prev, score) &#123; return prev + score; &#125;, 0);// ES6const sgTotalScore = playerInfo .filter(info =&gt; info.retired === true) .filter(info =&gt; info.position === 'SG') .map(info =&gt; info.score) .reduce((prev, score) =&gt; (prev || 0) + score);console.log(sgTotalScore1); // 55console.log(sgTotalScore2); // 55 화살표 함수 또한 ES5로 작성한 코드보다 코드량이 확실히 줄어들었습니다. parameter가 한 개이면 ()안에 매개변수를 넣을 필요가 없습니다. brackets {}이 없으면 return한 것과 같은 문법입니다. # class keyword이전 포스팅에 class에 대해 다룬 포스팅이 있으니 참고바랍니다. # GeneratorGenerator는 비동기코드를 동기적으로 프로그매밍 할 수 있도록 도와주는 편한 기능입니다. 1234567891011121314const data = [ &#123; name: 'Jason', profile: &#123; age: 33, gender: 'Male' &#125; &#125;, &#123; name: 'Jane', profile: &#123; age: 29, gender: 'Female' &#125; &#125;]; 위와 같은 데이터 구조(data)를 참조하여 다이어그램 순서대로 처리해서 결과값(gender)를 도출해야된다고 가정해봅시다.제너레이터를 좀 더 쉽게 사용하기 위해 co 라이브러리를 사용해서 실습해보겠습니다. 1234567891011121314151617181920212223const co = require('co');function getName(name) &#123; return data.filter((e) =&gt; e.name === name );&#125;function getProfile(name) &#123; return name.map((e) =&gt; e.profile);&#125;;function getGender(profile) &#123; const gender = profile[0].gender; return Promise.resolve(gender);&#125;;co(function* () &#123; const name = yield getName('Jason'); const profile = yield getProfile(name); const gender = yield getGender(profile); return gender;&#125;).then(result =&gt; &#123; console.log(result); // Male&#125;); yeild 표현을 통해 함수의 return 값을 반환합니다. 만약 콜백으로 처리했다면 코드는 스파게티 코드처럼 더럽혀져 있었을겁니다. 이번에는 co 라이브러리를 사용하지 않고 16 - 23번째 줄을 async/await 문법으로 바꿔 똑같은 결과물을 도출해보겠습니다. 12345678// (중략)async function showGender(personName) &#123; const name = await getName(personName); const profile = await getProfile(name); const gender = await getGender(profile); return gender;&#125;showGender('Jason').then(res =&gt; console.log(res)); // Male function* -&gt; async function, yield -&gt; await 두 개의 키워드만 바뀌었고 Promise로 반환하는 것까지 똑같습니다. 라이브러리의 도움없이 사용할 수 있는 장점이 있지만 아직 브라우저의 표준 스펙은 아닙니다. Wrap-up이전 회사에서 ES6로 자바스크립트 개발을 해본 경험이 있었지만 개념을 제대로 익히지 않고 개발을 진행하다보니 ES6 문법 및 기능을 최대한 활용하지 못했던 것 같습니다. 역시 기본이 중요하다는 것을 깨닫는 좋은 시간이었습니다. Reference비구조화 할당ES6의 제너레이터를 사용한 비동기 프로그래밍Get name->Get profile: name Get profile->Get gender: profile Note right of Get gender: gender{\"scale\":1,\"line-width\":2,\"line-length\":50,\"text-margin\":10,\"font-size\":12,\"theme\":\"simple\"} var code = document.getElementById(\"sequence-0-code\").value; var options = JSON.parse(decodeURIComponent(document.getElementById(\"sequence-0-options\").value)); var diagram = Diagram.parse(code); diagram.drawSVG(\"sequence-0\", options);","categories":[{"name":"Front-end","slug":"Front-end","permalink":"http://jason0853.github.io/categories/Front-end/"},{"name":"Javascript","slug":"Front-end/Javascript","permalink":"http://jason0853.github.io/categories/Front-end/Javascript/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://jason0853.github.io/tags/Javascript/"},{"name":"ES6","slug":"ES6","permalink":"http://jason0853.github.io/tags/ES6/"}]},{"title":"Creating a modal plugin with jQuery","slug":"Creating-a-modal-plugin-with-jQuery","date":"2018-02-18T15:21:37.000Z","updated":"2019-05-18T06:10:55.391Z","comments":true,"path":"2018/02/19/Creating-a-modal-plugin-with-jQuery/","link":"","permalink":"http://jason0853.github.io/2018/02/19/Creating-a-modal-plugin-with-jQuery/","excerpt":"","text":"UI 개발을 하다 보면 재사용하는 기능들을 플러그인으로 만들어서 사용하면 굉장히 편리합니다. 지난 포스팅해서 다뤘던 디자인 패턴(Design Pattern)들 응용해서 간단한 Modal Plugin을 제작해보겠습니다. # Getting ready to build plugin보통 UI 플러그인을 제작할 때 고려해야 하는 것들은 다음과 같습니다. CSS 파일을 제공할 것인가? 플러그인을 적용할 대상 태그는 무엇인가? 서드파티(third party) 라이브러리가 필요한가? 어떠한 메서드를 제공할 것인가? 어떠한 옵션을 제공할 것인가? index.html12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;!-- CSS 내용 --&gt; &lt;style type=\"text/css\"&gt; html, body, div &#123; height: 100%; position: relative; margin: 0; padding: 0; box-sizing: border-box; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 적용 대상 태그 --&gt; &lt;div id=\"modal\"&gt;&lt;/div&gt; &lt;button id=\"btn-show\"&gt;show&lt;/button&gt; &lt;!-- third party library 제공 --&gt; &lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/jquery/1.12.4/jquery.js\"&gt;&lt;/script&gt; &lt;script src=\"modal.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 위 코드에서 보듯이 고려해야할 세가지 사항을 반영하였습니다. 이제 본격적으로 modal.js 를 만들어 보겠습니다. # Let’s buildmodal.js1234;(function($) &#123; 'use strict'; &#125;(jQuery)); jQuery의 $ 별칭을 사용할 때 다른 라이브러리와의 충돌을 방지하기 위해 IIFE 즉시 호출 함수 표현식을 사용하여 문제를 해결하는 것을 권장합니다. ‘use strcit’를 함수 안에 적용함으로써 자바스크립트 코드를 좀 더 엄격하게 검사하고 적은 에러를 발생시킬 수 있습니다. modal.js1234567891011121314151617181920212223242526272829303132333435363738;(function($) &#123; 'use strict'; var modal = null, params = null, instance; // Constructor var Modal = function(opt) &#123; &#125;; // Public Modal.prototype = &#123; version: 'v1.0.0' &#125; // private modal = &#123; init: function() &#123; this.cacheDom(); this.bindEvents(); this.render(); &#125;, cacheDom: function() &#123; this.$window = $(window); this.$modal = $('#modal'); &#125;, bindEvents: function() &#123; &#125;, render: function() &#123; &#125;, &#125;; window.Modal = Modal;&#125;(jQuery)); 변수 modal은 Object Literal Pattern을 사용하여 각 기능을 작성할 예정입니다. 객체 리터럴이 생소하신 분들은 지난 포스팅을 참고해주시기 바랍니다. params는 옵션에 해당하는 객체의 결과값을 할당 받을 변수입니다. instance 변수는 Singleton Pattern을 적용하기 위해 미리 선언해두었습니다. 싱글톤 패턴에 대해 생소하신 분들은 지난 포스팅을 참고해주세요. Modal.prototype에 공개할 API 메서드를 return 할 예정입니다. UI 구조상 같은 유형의 모달을 동시에 여러개 띄우는 경우는 없으므로 싱글톤 패턴으로 만드는 것이 적합합니다. 그럼 constructor 부분애 코드를 추가해보겠습니다. modal.js12345678910111213141516171819202122232425262728293031323334353637383940414243;(function($) &#123; 'use strict'; var modal = null, params = null, instance; // Constructor var Modal = function(opt) &#123; var _self = this; function initialize() &#123; opt = opt || &#123;&#125;; var config = &#123; width: opt.width || 500, height: opt.height || 'auto', bgColor: opt.bgColor || '#eee', title: opt.title || 'Title', content: opt.content || 'Content' &#125;; params = $.extend(config, opt); modal.init(); return _self; &#125; return function() &#123; if (!instance) &#123; instance = initialize(); &#125; return instance; &#125;(); &#125;; // (중략) window.Modal = Modal;&#125;(jQuery)); $.extend() 메서드를 이용하여 config 객체(default)와 opt 객체(사용자가 변경할 옵션)를 merge 시킵니다. instance = initialize() 값을 할당시키고 난 이후 새로운 객체를 만들려고 해도 instance가 더이상 undefined가 아니기 때문에 새로운 객체를 만들 수가 없어 싱글톤 패턴을 구현하게 됩니다. modal.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293;(function($) &#123; 'use strict'; // (중략) // Public method Modal.prototype = &#123; version: 'v1.0.0', show: function() &#123; modal.show(); &#125;, hide: function() &#123; modal.hide(); &#125;, change: function(title, content) &#123; modal.change(title, content); &#125; &#125;; // private modal = &#123; init: function() &#123; this.cacheDom(); this.bindEvents(); this.render(); &#125;, cacheDom: function() &#123; this.$window = $(window); this.$modal = $('#modal'); &#125;, bindEvents: function() &#123; this.$window.on('resize', this.center.bind(this)); this.$modal.on('click', '#modal-dim', this.hide.bind(this)); &#125;, render: function() &#123; this.addDim(); this.create(); this.addTitle(); this.addContent(); this.center(); this.$modal.hide(); &#125;, create: function() &#123; var $modalBox = $('&lt;div class=\"modal-box\"&gt;&lt;/div&gt;'), boxStyles = &#123; zIndex: 100, width: params.width, height: params.height, background: params.bgColor &#125;; $modalBox.css(boxStyles).appendTo(this.$modal); &#125;, addDim: function() &#123; var $target = $('&lt;div id=\"modal-dim\"&gt;&lt;/div&gt;'), styles = &#123; position: 'absolute', left: 0, top: 0, right: 0, bottom: 0, width: '100%', height: '100%', background: '#000', opacity: .7 &#125;; $target.css(styles).appendTo(this.$modal); &#125;, addTitle: function() &#123; var $target = $('&lt;div id=\"modal-title\"&gt;&lt;/div&gt;'), $parentElem = this.$modal.find('.modal-box'), styles = &#123; width: '100%', height: '50px', lineHeight: '50px', fontSize: '1.5rem', fontWeight: 'bold', textAlign: 'center', borderBottom: '1px solid #ccc' &#125;; $target.css(styles).appendTo($parentElem).text(params.title); &#125;, addContent: function() &#123; var $target = $('&lt;div id=\"modal-content\"&gt;&lt;/div&gt;'), $parentElem = this.$modal.find('.modal-box'), styles = &#123; width: '100%', height: 'auto', padding: '1.5rem', wordWrap: 'break-word' &#125;; $target.css(styles).appendTo($parentElem).text(params.content); &#125;, center: function() &#123; var $target = this.$modal.find('.modal-box'), wid = this.$window.width(), hei = this.$window.height(), targetWid = $target.width(), targetHei = $target.height(), styles = &#123; 'position': 'absolute', 'left': (wid - targetWid) / 2, 'top': (hei - targetHei) / 2&#125;; $target.css(styles); &#125;, show: function() &#123; this.$modal.show(); &#125;, hide: function() &#123; this.$modal.hide(); &#125;, change: function(title, content) &#123; var $title = this.$modal.find('#modal-title'), $content = this.$modal.find('#modal-content'); params.title = title; params.content = content; $title.text(title); $content.text(content); &#125; &#125; window.Modal = Modal;&#125;(jQuery)); modal 객체에 method로 있는 show, hide, change를 Modal.prototype에 공개 API로 추가해줌으로써 새로운 인스턴스 객체가 생성되었을 때 Modal 생성자 속성 및 메서드에 접근할 수 있게 됩니다. 아래코드는 modal.js 의 전체 코드입니다. # How to use1234567var myModal = new Modal(&#123; width: 300, title: '타이틀', content: '내용'&#125;);$('#btn-show').on('click', myModal.show); 아래와 같이 show 버튼을 클릭하면 modal이 노출되고 dim부분을 클릭하면 modal이 사라집니다. 이번엔 change() 메서드를 이용하여 title과 content 파라미터를 변경해보겠습니다. 12345678910var myModal = new Modal();$('#btn-show').on('click', function() &#123; myModal.change('타이틀', '내용'); myModal.show();&#125;);$('#btn-error').on('click', function() &#123; myModal.change('에러', '에러입니다.'); myModal.show();&#125;); Wrap-up간단한 플러그인이지만 실제로 이렇게 만들어 보는 것이 중요한 것 같습니다. 자바스크립트 이론을 공부하면서 ‘실제로 개발할 때 어디에 적용해야되는걸까?’라는 의문을 던지게 됩니다. 예를 들어 싱글톤 패턴을 포스팅하면서도 개념만 익혔지 어디에 활용해야될지 사실 잘 몰랐습니다.ㅠㅠ 반성하게 됩니다.ㅎㅎ 포스팅이 생각보다 길어져서 중간중간 실수한 흔적이 보일 수도 있습니다. 혹시 수정해야할 부분이 있다면 댓글 부탁드립니다. Reference자바스크립트에서 strict mode를 사용해야 하는 이유모던 웹을 위한 JavaScript jQuery 입문 - 한빛미디어","categories":[{"name":"Front-end","slug":"Front-end","permalink":"http://jason0853.github.io/categories/Front-end/"},{"name":"Javascript","slug":"Front-end/Javascript","permalink":"http://jason0853.github.io/categories/Front-end/Javascript/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://jason0853.github.io/tags/Javascript/"},{"name":"Design Pattern","slug":"Design-Pattern","permalink":"http://jason0853.github.io/tags/Design-Pattern/"},{"name":"jQuery","slug":"jQuery","permalink":"http://jason0853.github.io/tags/jQuery/"}]},{"title":"2018 카카오 코딩 테스트 (캐시)","slug":"2018-kakao-blind-recruitment-round-1-3","date":"2018-02-18T07:52:13.000Z","updated":"2019-05-18T06:10:55.390Z","comments":true,"path":"2018/02/18/2018-kakao-blind-recruitment-round-1-3/","link":"","permalink":"http://jason0853.github.io/2018/02/18/2018-kakao-blind-recruitment-round-1-3/","excerpt":"","text":"이번 문제는 난이도가 지난 포스팅보다 쉬워서 조금 빨리 풀 수 있었습니다. 한번 같이 문제를 살펴볼까요?ㅋㅋ 우선 제목에서도 볼 수 있듯이 캐시와 관련된 문제입니다. 캐시는 실제 개발할 때도 성능 개선을 하는데 있어서 중요한 부분을 차지하기 때문에 개발자들이 한번씩 같이 풀어보면 좋은 문제라고 생각합니다. 문제를 풀기 전에 주의할 점이나 모르는 용어들을 한 번 정리해보겠습니다. 대소문자를 구분하지 않는 점. LRU(Least Recently Used) - cache(임시 저장소)에 저장시킬때 공간이 부족하여 오래된 데이터를 퇴출시키고 새로운 데이터로 교체하는 가장 효율이 좋은 알고리즘. cache hit - 캐시에 참조하려는 데이터가 존재할 때. cache miss - 캐시에 참조하려는 데이터가 존재하지 않을 때. 입출력 및 조건 등을 다 읽어보니 실행시간을 구해내야합니다. 그럼 한번 알고리즘을 구현해보겠습니다. 123456789101112131415161718192021222324252627282930313233343536373839const test = [ &#123; cacheSize: 3, cities: [\"Jeju\", \"Pangyo\", \"Seoul\", \"NewYork\", \"LA\", \"Jeju\", \"Pangyo\", \"Seoul\", \"NewYork\", \"LA\"] &#125;, &#123; cacheSize: 3, cities: [\"Jeju\", \"Pangyo\", \"Seoul\", \"Jeju\", \"Pangyo\", \"Seoul\", \"Jeju\", \"Pangyo\", \"Seoul\"] &#125;, &#123; cacheSize: 2, cities: [\"Jeju\", \"Pangyo\", \"Seoul\", \"NewYork\", \"LA\", \"SanFrancisco\", \"Seoul\", \"Rome\", \"Paris\", \"Jeju\", \"NewYork\", \"Rome\"] &#125;, &#123; cacheSize: 5, cities: [\"Jeju\", \"Pangyo\", \"Seoul\", \"NewYork\", \"LA\", \"SanFrancisco\", \"Seoul\", \"Rome\", \"Paris\", \"Jeju\", \"NewYork\", \"Rome\"] &#125;, &#123; cacheSize: 2, cities: [\"Jeju\", \"Pangyo\", \"NewYork\", \"newyork\"] &#125;, &#123; cacheSize: 0, cities: [\"Jeju\", \"Pangyo\", \"Seoul\", \"NewYork\", \"LA\"] &#125;];function cache(cacheSize, cities) &#123; const cache = [], HIT = 1, MISS = 5; let time = 0; if (cacheSize === 0) return MISS * cities.length; cities.forEach((val) =&gt; &#123; const city = val.toLowerCase(), currentSize = cache.length, cacheIdx = cache.indexOf(city); if (cacheIdx &gt; -1) &#123; time += HIT; cache.splice(cacheIdx, 1); cache.push(city); &#125; else &#123; if (currentSize &gt;= cacheSize) cache.shift(); time += MISS; cache.push(city); &#125; &#125;); return time;&#125;for (let obj of test) &#123; console.log(cache(obj.cacheSize, obj.cities));&#125;// output: 50, 21, 60, 52, 16, 25 cahceSize === 0일 때는 cities를 Loop 처리해줄 필요가 없기 때문에 단순 연산을 한 뒤 return 시킵니다. 대소문자를 구분하지 않는다고 했으니 toLowerCase()를 이용하여 문자열을 소문자로 바꿔 city라는 변수에 할당시킵니다. cache.indexOf(city)를 실행시키면 일치하는 값이 있을 경우 해당 배열 index 값을 반환시켜주고 일치하는 값이 없을 경우 -1을 반환시켜줍니다. 주의) 입출력 예제에 없는 다른 유형의 예제도 고려해야함 123456// cache size가 3일 경우[&quot;New York&quot;, &quot;LA&quot;, &quot;Las Vegas&quot;, &quot;LA&quot;]| new york | | || new york | la | || new york | la | las vegas || new york | las vegas | la | 문제 해설을 읽어보니 정답률이 많이 낮았습니다. 아마도 다른 경우를 고려하지 않고 답을 도출했을 경우 많이 틀렸을 것으로 예상됩니다. 솔직히 저도 스터디하는 친구가 코드 리뷰를 해주지 않았다면 이전 코드를 가지고 포스팅 했을겁니다.ㅠㅠ 그러나 이번 문제를 통해 LRU 알고리즘을 알게 된 좋은 계기가 되었던 것 같습니다. Wrap-up일주일에 한번씩 스터디를 진행하고 있는데 서로 짠 코드를 리뷰하는 것은 정말 많은 장점을 가진 것 같습니다. 미처 생각하지 못한 로직이나 성능, 그리고 코드 가독성 등 많은 것을 다른 동료한테 배울 수 있어서 너무 좋았습니다. Reference카카오톡 문제 및 해설","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://jason0853.github.io/categories/Algorithm/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://jason0853.github.io/tags/Javascript/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://jason0853.github.io/tags/Algorithm/"}]},{"title":"2018 카카오 코딩 테스트 (다트 게임)","slug":"2018-kakao-blind-recruitment-round-1-2","date":"2018-02-12T08:57:13.000Z","updated":"2019-05-18T06:10:55.390Z","comments":true,"path":"2018/02/12/2018-kakao-blind-recruitment-round-1-2/","link":"","permalink":"http://jason0853.github.io/2018/02/12/2018-kakao-blind-recruitment-round-1-2/","excerpt":"","text":"지난 포스팅에 이어 신입 공채 두번째 문제를 풀어보도록 하겠습니다. 지난번 문제보다는 살짝 어렵지만 너무 겁먹지 마세요. 막상 풀면 별거 아닌것 같습니다.ㅋㅋ 문제가 길어서 이해하는데 지난번보다 오래 걸렸습니다. 위 문제 내용을 한번 요약해보겠습니다. 총 기회는 3번 점수는 0-10점까지 (10점 두 자릿수이기 때문에 유의!) S - 제곱, D - 2제곱, T - 3제곱 스타상(*) - 2배, 해당 점수 및 이전 점수 2배, 스타상끼리 중첩시 4배 아차상(#) - 해당 점수 마이너스, 스타상과 중첩시 마이너스 2배 입출력 예제를 참고해서 똑같은 answer를 도출해보겠습니다. 123456789101112131415161718192021222324252627282930313233343536373839404142const dartResult = ['1S2D*3T', '1D2S#10S', '1D2S0T', '1S*2T*3S', '1D#2S*3S', '1T2D3D#', '1D2S3T*'];function dart(point) &#123; const scores = point.match(/\\d+/g), bonus = point.match(/[SDT]/g), bonusOpt = point.match(/[SDT][#\\*]?/g), temp = []; let result = 0; for (let i = 0; i &lt; 3; i++) &#123; const score = Number(scores[i]); opt = bonusOpt[i].replace(/[SDT][\\*]/g, '*').replace(/[SDT][#]/g, '#').replace(/[SDT]/g, null); switch (bonus[i]) &#123; case 'D': temp.push(Math.pow(score, 2)); break; case 'T': temp.push(Math.pow(score, 3)); break; default: temp.push(score); &#125; switch (opt) &#123; case '*': if (i === 2) &#123; temp.map((score, idx) =&gt; &#123; if (idx !== 0) temp[idx] = score * 2 &#125;); &#125; else temp.map((score, idx) =&gt; temp[idx] = score * 2); break; case '#': temp[i] = temp[i] * -1; &#125; &#125; for (let i = 0; i &lt; 3; i++) result += temp[i]; return result;&#125;for (let point of dartResult) &#123; console.log(dart(point));&#125;// output: 37, 9, 3, 23, 5, -4, 59 숫자(1-10), 영문(SDT), 특수문자(#/*)를 match() 메서드를 이용하여 각 문자열을 배열로 반환해서 각 변수에 저장해두었습니다.정규식 \\d+ 통하여 두자릿수 숫자 10을 해결하였습니다. 보너스와 옵션을 묶어서 bonusOpt 변수를 따로 둔 이유는 특수문자만 정규식을 사용하여 처리할 경우 스타상(*)과 아차상(#)을 몇번째 점수에 처리해야될지 미지수이기 때문입니다. replace() 메서드를 이용하여 스타상이 있을 경우(*), 아차상이 있을 경우(#), 둘다 없을 경우(null) 값으로 처리하여 배열로 반환합니다. Math.pow() 메서드를 이용하여 점수와 보너스 거듭 제곱 연산처리를 해줍니다. 문자열 ‘S’는 1제곱이므로 따로 할 필요가 없습니다. 스타상(*)일 경우 조건문을 통해 해당 점수의 이전 점수까지만 2배 처리를 해줍니다.조건문이 추가되지 않고 세번째 점수에 아차상이 존재할 경우 모든 점수에 2배 점수가 적용됩니다. 이 부분에 유의해주세요. 문제 해설을 보니 정규식을 이용하여 문자열 처리를 잘 활용할 수 있는지 묻는 문제였습니다. Wrap-up결국 문제는 풀었지만 최적화에 대해 좀 더 고민을 해야될 것 같습니다. 여유가 생기면 다시 한번 고민해서 풀어보고 포스팅 해보겠습니다. 그리고 이번 다트 게임 문제를 통하여 정규식 공부를 열심히 해야겠다는 생각을 하게 되었습니다. 매번 구글링을 통해 copy/paste 했던 제 자신이 한심해지네요.ㅠㅠ 위 코드에 잘못된 부분이나 좀 더 나은 로직을 공유해주실 분은 댓글 부탁드립니다. Reference카카오톡 문제 및 해설","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://jason0853.github.io/categories/Algorithm/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://jason0853.github.io/tags/Javascript/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://jason0853.github.io/tags/Algorithm/"}]},{"title":"Singleton Pattern","slug":"Singleton-Pattern","date":"2018-02-05T08:34:34.000Z","updated":"2019-05-18T06:10:55.390Z","comments":true,"path":"2018/02/05/Singleton-Pattern/","link":"","permalink":"http://jason0853.github.io/2018/02/05/Singleton-Pattern/","excerpt":"","text":"Singleton Pattern(싱글톤 패턴)은 ‘single’이라는 단어 그대로 오직 하나의 객체 생성만을 허용하는 것을 뜻합니다. # Object Literal12345678910111213141516const p1 = &#123; name: 'Jason', sayName: function() &#123; return this.name; &#125;&#125;;const p2 = &#123; name: 'Jason', sayName: function() &#123; return this.name; &#125;&#125;;console.log(p1 == p2); // falseconsole.log(p1 === p2); // false p1, p2 객체의 속성과 메서드는 같지만 객체를 비교해보면 false가 나옵니다. Object Literal을 이용한 객체 생성 방법은 이미 싱글톤 패턴과 동일합니다.주의) Object Literal은 객체의 속성들이 전부 공개되어 외부에서 조작할 수 있는 단점이 있습니다. # Singleton Pattern그럼 이제 제대로 된(비공개) 싱글톤 패턴을 만들어 보겠습니다. 12345678910111213141516171819202122232425262728293031323334const singleton = (function() &#123; let instance; function init() &#123; const name = 'single'; function show() &#123; return name; &#125; return &#123; name: name, show: show &#125; &#125; return &#123; getInstance: function() &#123; if (!instance) &#123; instance = init(); &#125; return instance; &#125; &#125;&#125;)();const single1 = singleton.getInstance();const single2 = singleton.getInstance();console.log(single1 == single2); // trueconsole.log(single1 === single2); // truesingle1.name = 'Singleton Pattern';console.log(single2.name); // 'Singleton Pattern' IIFE(즉시 호출 패턴)을 사용하여 외부에서 접근하지 못하도록 막아줍니다. init() 함수 내부에 private(비공개) 변수 및 함수를 선언해주고 반환시켜줍니다. getInstance는 유일한 공개 메서드입니다. 처음 호출할 때 instance 변수가 undefined이기 때문에 init() 함수를 호출한 뒤에 instance 변수에 init 함수 리턴값을 저장시켜줍니다. 두번째 호출할 때는 instance값에 처음 호출된 객체값이 저장되어 있기 때문에 init 함수를 호출하지 않고 바로 리턴시킵니다. 싱글톤이기 때문에 single1.name 속성이 바뀌면 single2.name도 변경됩니다. Wrap-up싱글톤 패턴 특징 하나의 객체만 생성. 동일한 객체의 다수의 인스턴스 허용. 여러 객체를 만들지 못하도록 제한하고 첫번째 객체가 생성된 후에는 첫번째 객체 자체를 리턴시킵니다. Reference4 JavaScript Design Patterns You Should Know","categories":[{"name":"Front-end","slug":"Front-end","permalink":"http://jason0853.github.io/categories/Front-end/"},{"name":"Javascript","slug":"Front-end/Javascript","permalink":"http://jason0853.github.io/categories/Front-end/Javascript/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://jason0853.github.io/tags/Javascript/"},{"name":"Design Pattern","slug":"Design-Pattern","permalink":"http://jason0853.github.io/tags/Design-Pattern/"}]},{"title":"2018 카카오 코딩 테스트 (비밀 지도)","slug":"2018-kakao-blind-recruitment-round-1-1","date":"2018-02-05T04:41:22.000Z","updated":"2019-05-18T06:10:55.390Z","comments":true,"path":"2018/02/05/2018-kakao-blind-recruitment-round-1-1/","link":"","permalink":"http://jason0853.github.io/2018/02/05/2018-kakao-blind-recruitment-round-1-1/","excerpt":"","text":"최근 카카오에서 신입 공채로 코딩 테스트를 진행했었습니다. 문제들을 보니 재미있을 것 같아서 한번 풀어보고 블로그에 포스팅 해보기로 하였습니다.우선 1번 문제인 비밀지도(난이도: 하) 문제부터 차례대로 포스팅해보겠습니다. 그림과 문제를 보고 저 나름대로 짧게 다시 요약해보겠습니다. 첫번째 지도 + 두번째 지도 = 세번째 지도 # = 1, 공백 = 0 두 지도와 2진수를 각각 비교해보겠습니다. 예를 들어 빨강색으로 표시된 부분만 한 번 비교해보겠습니다. 1234567891011// 지도 비교#### # #-----### #// 이진수 비교1110010101-----11101 결국 이진수 11101은 ###공백#입니다. 입출력 예제에서 첫번째 매개변수 값과 두번째 매개변수 값을 가지고 출력이 똑같이 나오도록 하겠습니다. 1234567891011121314151617181920212223242526272829303132333435363738394041function addZero(digits, data) &#123; const zero = '0'; if (data.length !== digits) &#123; for (let i = 0, len = digits - data.length; i &lt; len; i++) &#123; data = zero + data; &#125; &#125; return data;&#125;function secretMap(n, arr1, arr2) &#123; const result = []; let testNum1, testNum2; for (let i = 0; i &lt; n; i++) &#123; testNum1 = arr1[i].toString(2); testNum2 = arr2[i].toString(2); testNum1 = addZero(n, testNum1); testNum2 = addZero(n, testNum2); let chars = ''; for (let i = 0; i &lt; n; i++) &#123; if (Number(testNum1[i]) || Number(testNum2[i])) chars += '#'; else chars += ' '; &#125; result.push(chars); &#125; return result;&#125;secretMap(5, [9, 20, 28, 18, 11], [30, 1, 21, 17, 28]);secretMap(6, [46, 33, 33 ,22, 31, 50], [27 ,56, 19, 14, 14, 10]);// output1 : [\"#####\",\"# # #\", \"### #\", \"# ##\", \"#####\"]// output2 : [\"######\", \"### #\", \"## ##\", \" #### \", \" #####\", \"### # \"] toString(2) 메서드를 통해 10진수를 2진수로 변경합니다. addZero 메서드를 통해 0을 앞에 추가하면서 자릿수를 맞춰줍니다. || OR 연산자를 통해 하나라도 참이면 ‘#’, 둘 다 거짓이면 공백 처리를 해줍니다. 정답은 맞혔지만 위 문제 해설을 보면은 비트 연산을 잘 활용할 수 있는지를 묻는 문제였습니다. 그럼 비트 연산을 통해 다시 풀어보겠습니다. 1234567891011121314151617function secretMap(n, arr1, arr2) &#123; const result = []; for (let i = 0; i &lt; n; i++) &#123; const int = (arr1[i] | arr2[i]); const binary = int.toString(2); result.push(binary.replace(/1/g, '#').replace(/0/g, ' ')); &#125; return result;&#125;secretMap(5, [9, 20, 28, 18, 11], [30, 1, 21, 17, 28]);secretMap(6, [46, 33, 33 ,22, 31, 50], [27 ,56, 19, 14, 14, 10]);// output1 : [\"#####\",\"# # #\", \"### #\", \"# ##\", \"#####\"]// output2 : [\"######\", \"### #\", \"## ##\", \" #### \", \" #####\", \"### # \"] | 비트 연산 OR을 사용하면 연산 자체는 2진수로 하지만 반환값은 자바스크립트 표준값으로 나옵니다.예) 9 | 30 = 31 toString(2)을 통해 2진수 값으로 변환합니다. replace() 메서드를 통해 2진수 문자열을 1일 때 ‘#’, 0일 때 공백 처리를 해줍니다. 첫번째 인자에 있는 플래그(Flag) g는 문자열 전체를 검색해줍니다. Wrap-up블로그를 포스팅하면서 첫번째 알고리즘을 다뤄봤습니다. 비트 연산을 묻는 의도인 것을 파악하지 않고 풀었을 경우와 알고 풀었을 경우의 코드를 비교해보니 코드량이 1/3로 줄었습니다. 포스팅을 보신 뒤 잘못된 부분이나 좀 더 최적화 코드를 공유해주실 분은 댓글 부탁드립니다. Reference카카오톡 문제 및 해설","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://jason0853.github.io/categories/Algorithm/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://jason0853.github.io/tags/Javascript/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://jason0853.github.io/tags/Algorithm/"}]},{"title":"Functional Programming","slug":"Functional-Programming","date":"2018-02-02T06:37:46.000Z","updated":"2019-05-18T06:10:55.389Z","comments":true,"path":"2018/02/02/Functional-Programming/","link":"","permalink":"http://jason0853.github.io/2018/02/02/Functional-Programming/","excerpt":"","text":"Functional Programming(함수형 프로그래밍)은 기존 객체지향 프로그래밍처럼 객체에 존재하는 property나 method를 사용하는 것과 달리 이름 그대로 함수를 기반으로 프로그래밍하는 기법입니다. 최근 개발자들 사이에서 함수형 프로그래밍이 trend로 잡고 있는데 어떤 점이 좋은지 한번 정리해보겠습니다. # The advantage of Functional Programming 버그가 적음. 추론하기가 쉬움. 시간 절약. 우선 기본적으로 함수형 프로그래밍을 어떻게 하는지 알아보겠습니다. 1234567let sum = function(a) &#123; return a + 3;&#125;;let result = sum;result(3); // 6 위 코드처럼 함수는 변수에 할당될 수 있으며 입출력이 순수하기 하기 때문에 side-effect가 전혀 없습니다. 그럼 자바스크립트에서 Higher-Order Function하면 자주 언급되는 함수들과 필요한 개념들을 한번 살펴보겠습니다. # Filter조건에 부합하는 값들을 필터링해서 새로운 배열을 반환합니다. 1234567891011121314151617181920212223242526272829let _ = require('underscore');let players = [ &#123; name: 'Kyrie Irving', retire: false &#125;, &#123; name: 'Kobe Bryant', retire: true &#125;, &#123; name: 'Tracy Mcgrady', retire: true &#125;, &#123; name: 'Aaron Gordon', retire: false &#125;, &#123; name: 'Tim Duncan', retire: true &#125;];let isRetired = function(player) &#123; return player.retire === true;&#125;;let retiredPlayers = players.filter(isRetired);let currentPlayers = _.reject(players, isRetired);/* Output: retiredPlayers *//* [ &#123; name: 'Kobe Bryant', retire: true &#125;, &#123; name: 'Tracy Mcgrady', retire: true &#125;, &#123; name: 'Tim Duncan', retire: true &#125; ]*//* Output: currentPlayers *//* [ &#123; name: 'Kyrie Irving', retire: false &#125;, &#123; name: 'Aaron Gordon', retire: false &#125; ]*/ filter라는 자바스크립트 내장 함수를 사용함으로써 for loop와 if 구문을 사용할 필요가 없어졌습니다. 결론적으로 코드는 좀 더 간결해졌습니다. isRetired 변수를 함수형으로 표현함으로써 재사용성이 높아지게 되었습니다. # Map기존 데이터에서 필요한 값들만 추출해서 새로운 배열을 반환합니다. 1234567891011121314let players = [ &#123; name: 'Kyrie Irving', retire: false &#125;, &#123; name: 'Kobe Bryant', retire: true &#125;, &#123; name: 'Tracy Mcgrady', retire: true &#125;, &#123; name: 'Aaron Gordon', retire: false &#125;, &#123; name: 'Tim Duncan', retire: true &#125;];let names = players.map(x =&gt; x.name); // arrow function(=&gt;) - es6 문법// Output: names/*[\"Kyrie Irving\", \"Kobe Bryant\", \"Tracy Mcgrady\", \"Aaron Gordon\", \"Tim Duncan\"]*/ ES6 문법을 사용하여 코드를 한 줄로 정리하였습니다. 파라미터명을 player라고 명명할수도 있지만 함수형 프로그래밍에서는 x라고 짧게 하는 것이 일반적입니다. # Reduce기존 데이터 값들을 가지고 연산에 의해 반환되는 값을 구할때 주로 사용하는 메서드입니다. 123456789101112let orders = [ &#123; price: 30000 &#125;, &#123; price: 1000 &#125;, &#123; price: 5000 &#125;, &#123; price: 10000 &#125;, &#123; price: 20000 &#125;,];let totalPrice = orders.reduce((sum, order) =&gt; sum + order.price, 0); // arrow function(=&gt;) - es6 문법// Output: totalPrice// 66000 reduce의 두번째 파라미터는 초기값을 설정해주기 때문에 변수로 initial 값을 지정해 줄 필요가 없어졌습니다. # ClosureClosure(클로저)란 외부함수가 실행이 끝났음에도 불구하고 내부함수가 외부함수의 변수에 접근할 수 있는 것을 가리킵니다. 123456789101112let count = function() &#123; let _number = 0; return function() &#123; _number++; return _number; &#125;&#125;;let increase = count(); // increase -&gt; 클로저increase(); // 1increase(); // 2increase(); // 3 count() 함수가 실행되어 내부함수를 return하여 종료되었음에도 불구하고 increase() 함수는 호출되면서 count 함수의 지역변수인 _number에 접근하게 되어 값이 제대로 출력됩니다. increase에서 클로저가 생성됩니다. 이번에 조금 다른 예제로 클로저를 다뤄보겠습니다. 12345678910function makeNumber(a) &#123; return function(b) &#123; return a + b; &#125;;&#125;var sum3 = makeNumber(3); // sum3 -&gt; 클로저var sum5 = makeNumber(5); // sum5 -&gt; 클로저sum3(10); // 13sum5(10); // 15 makeNumber는 두 개의 새로운 함수들을 만들기 위해 함수 팩토리를 사용합니다. a 인자를 보통 자유변수라고 부르며 b 인자를 묶인 변수라고 합니다. 문법적 환경으로 바라보았을 때 sum3의 a = 3이며, sum5의 a = 5입니다. # CurryingCurrying(커링)은 한 번에 모든 인자를 전달하지 않고 첫번째 인자를 전달하고 두번째 인자를 전달할 새 함수를 반환합니다. 이렇게 인자의 일부만 받도록 하는 기법을 커링이라고 부릅니다. 123456789101112let person = name =&gt; age =&gt; job =&gt; `I'm $&#123;name&#125;. I'm $&#123;age&#125;. I work as a $&#123;job&#125;.`;let personName = person('Jason');let personAge = personName(33);personAge('Front-end Engineer');/* Output */// I'm Jason. I'm 33. I work as a Front-end Engineer. person 함수는 커링 기법을 사용할 수 있게 파라미터 이후에 함수를 계속 리턴해주었습니다. 123456789101112const _ = require('lodash');let person = (name, age, job) =&gt; `I'm $&#123;name&#125;. I'm $&#123;age&#125;. I work as a $&#123;job&#125;`;person = _.curry(person);let personName = person('Jason'); let personAge = personName(33);personAge('Front-end Engineer');/* Output */// I'm Jason. I'm 33. I work as a Front-end Engineer. lodash 라이브러리를 이용하여 person 함수를 커링할 수 있는 함수로 만들어 보았습니다. 위에서 filter 함수를 다뤄보았을 때 underscore 라이브러리를 사용하여 은퇴한 선수들과 현역 선수들을 구분했었습니다. 이번에는 lodash의 curry 함수를 사용하여 구분해보겠습니다. 123456789101112131415161718192021222324252627const _ = require('lodash');let players = [ &#123; name: 'Kyrie Irving', retire: false &#125;, &#123; name: 'Kobe Bryant', retire: true &#125;, &#123; name: 'Tracy Mcgrady', retire: true &#125;, &#123; name: 'Aaron Gordon', retire: false &#125;, &#123; name: 'Tim Duncan', retire: true &#125;];let retired = _.curry((val, obj) =&gt; obj.retire === val);let retiredPlayers = players.filter(retired(true));let currentPlayers = players.filter(retired(false));/* Output: retiredPlayers *//* [ &#123; name: 'Kobe Bryant', retire: true &#125;, &#123; name: 'Tracy Mcgrady', retire: true &#125;, &#123; name: 'Tim Duncan', retire: true &#125; ]*//* Output: currentPlayers *//* [ &#123; name: 'Kyrie Irving', retire: false &#125;, &#123; name: 'Aaron Gordon', retire: false &#125; ]*/ # RecursionRecursion(재귀)는 함수가 자기 자신을 호출하는 것을 말하며, 어느 조건을 주었을 경우 만족할 때까지 반복문처럼 계속 호출합니다. 함수형 프로그래밍에서는 반복문 대신 재귀를 사용합니다. 123456789101112131415161718192021let count = (num) =&gt; &#123; if (num === 0) return; console.log(num); count(num-1);&#125;;count(10);/* Output *//*10987654321*/ count 함수는 0이 되기 전까지 계속 자기 자신을 호출하기 때문에 재귀함수라고 할 수 있습니다. 이번에는 재귀함수를 응용해서 object tree 구조를 한 번 만들어보겠습니다. 12345678910111213141516171819202122let categories = [ &#123; id: 'human', parent: null &#125;, &#123; id: 'men', parent: 'human' &#125;, &#123; id: 'women', parent: 'human' &#125;, &#123; id: 'jason', parent: 'men' &#125;, &#123; id: 'tom', parent: 'men' &#125;, &#123; id: 'jane', parent: 'women' &#125;,];/* Result */&#123; human: &#123; men: &#123; 'jason': &#123;&#125;, 'tom': &#123;&#125; &#125;, women: &#123; 'jane': &#123;&#125;, &#125; &#125;&#125; categories라는 데이터베이스가 있다고 가정하고 재귀함수를 사용하여 위와 같이 똑같은 결과값이 나오도록 해보겠습니다. 1234567891011121314151617181920212223242526272829303132333435let categories = [ &#123; id: 'human', parent: null &#125;, &#123; id: 'men', parent: 'human' &#125;, &#123; id: 'women', parent: 'human' &#125;, &#123; id: 'jason', parent: 'men' &#125;, &#123; id: 'tom', parent: 'men' &#125;, &#123; id: 'jane', parent: 'women' &#125;];let makeObjectTree = (categories, parent) =&gt; &#123; let obj = &#123;&#125;; categories .filter(c =&gt; c.parent === parent) .forEach(c =&gt; obj[c.id] = makeObjectTree(categories, c.id)); return obj;&#125;;JSON.stringify(makeObjectTree(categories, null), null, 2);/* Output *//*&#123; human: &#123; men: &#123; 'jason': &#123;&#125;, 'tom': &#123;&#125; &#125;, women: &#123; 'jane': &#123;&#125;, &#125; &#125;&#125;*/ JSON.stringify()를 사용해서 자바스크립트 값을 JSON 문자열로 변경하였습니다. 주의) 반복문보다 속도가 느리며 stack을 사용하기 때문에 재귀호출이 많아지면 성능상에 이슈가 발생합니다. # PromisePromise는 콜백처럼 비동기를 다루는 방식 중에 하나입니다. 123456789101112131415161718let test = (str) =&gt; new Promise((reslove, reject) =&gt; &#123; if (typeof str === 'string') &#123; reslove(str); &#125; else &#123; let msg = 'This argument must be string'; reject(new Error(msg)); &#125;&#125;);let arr = [];Promise.all([ test('test1'), test('test2'), test('test3') ]) .then(data =&gt; &#123; data.forEach((val) =&gt; arr.push(val)); &#125;) .catch(err =&gt; console.error(err));console.log(arr); // [\"test1\", \"test2\", \"test3\"] Promise는 ECMA6의 글로벌 객체에 포함되어 있으며 표준으로 채택되었습니다. Promise의 가장 큰 장점은 콜백 지옥에서 벗어날 수 있다는 점입니다. # FunctorFunctor는 map(매핑)될 수 있는 객체이며, 주로 컴퓨터 공학에서 사용됩니다. 기존 값들은 유지 및 변형시키면서 새로운 결과물(functor)를 얻게 됩니다. 아래 예제를 통해 한번 설명을 해보겠습니다. 12345const arr = [1, 2, 3, 4, 5];const newArr = arr.map(num =&gt; num * 2);console.log(newArr); // [2, 4, 6, 8, 10] map 메서드를 통해 변형이 일어납니다. 하지만 기존 arr 배열안에 있는 값들은 바뀌지 않습니다. newArr은 map 메서드를 통해 새로운 배열, 즉 매핑될 수 있는 새로운 functor를 얻게 됩니다. 아래 코드도 위와 같은 functor의 또 다른 예제입니다. 123456789101112131415const arr = [ &#123; name: 'Jason', age: 33 &#125;, &#123; name: 'Jane', age: 28 &#125;, &#123; name: 'Tom', age: 37&#125;];const newArr = arr.map(obj =&gt; &#123; let newObj = &#123;&#125;; newObj[obj.name] = obj.age; return newObj;&#125;);console.log(newArr); // [&#123;\"Jason\":32&#125;,&#123;\"Jane\":30&#125;,&#123;\"Tom\":31&#125;] Wrap-up함수형 프로그래밍의 특징 High Order Function을 통한 코드 재사용성. 항상 부작용이 없는 Pure Function 유지. for, if구문식보다는 표현식 사용. Immutable한 데이터 구조. 지금까지 함수형 프로그래밍을 다루면서 필요한 개념들을 다뤄보았습니다. 위 포스팅에 잘못된 내용이나 오타가 있는 부분은 댓글 부탁드립니다. ReferenceMozilla - 클로저함수형 프로그래밍이란 무엇인가?","categories":[{"name":"Front-end","slug":"Front-end","permalink":"http://jason0853.github.io/categories/Front-end/"},{"name":"Javascript","slug":"Front-end/Javascript","permalink":"http://jason0853.github.io/categories/Front-end/Javascript/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://jason0853.github.io/tags/Javascript/"}]},{"title":"Using design pattern to refactory jQuery spaghetti code","slug":"Using-design-pattern-to-refactory-jQuery-spaghetti-code","date":"2018-01-23T05:56:06.000Z","updated":"2019-05-18T06:10:55.389Z","comments":true,"path":"2018/01/23/Using-design-pattern-to-refactory-jQuery-spaghetti-code/","link":"","permalink":"http://jason0853.github.io/2018/01/23/Using-design-pattern-to-refactory-jQuery-spaghetti-code/","excerpt":"","text":"jQuery 라이브러리를 이용하여 화면 개발을 많이 했었지만 Javascript 공부를 제대로 하지 않고 코드를 짜면 엉망진창이 되기 쉽상이었습니다. 특히 프로젝트가 끝나고 유지보수 단계에 들어가면 한군데 수정하면 다른데도 수정해야되고 정말 귀찮았습니다. 그래서 Javascript 기본 개념을 다시 깨우치고 공부하면서 터득한 걸 공유해보겠습니다. 일단 앞으로 만들 결과물을 한 번 공개해보겠습니다. 간단히 결과물을 설명해드리면, 좋아하는 선수 이름을 리스트에 추가, 삭제하는 기능과 라디오버튼이 on이였을 경우 count를 하고 off였을 경우는 count를 하지 않는 기능을 넣는 simple한 apllication입니다. CDN을 통해 jquery 1.12.4를 추가하였습니다. 이제 js 소스를 한번 살펴보겠습니다. script.js123456789101112131415161718192021222324252627282930313233343536373839404142434445var players = [];checkCount();$('#player').find('button').on('click', function() &#123; var value = $('#player').find('input').val(), item = ` &lt;li&gt; &lt;span&gt;$&#123;value&#125;&lt;/span&gt; &lt;button type=\"button\"&gt;Delete&lt;/button&gt; &lt;/li&gt; `; if (!value) &#123; alert('Player 이름을 입력해주세요.'); return; &#125; $('#player').find('ul').append(item); players.push(value); $('#player').find('input').val(''); checkCount();&#125;);$('#player').find('ul').on('click', 'button', function(e) &#123; var $remove = $(e.target).closest('li'), idx = $('#player').find('ul').find('li').index($remove); $remove.remove(); players.splice(idx, 1); checkCount();&#125;);$('#count').find('.radios').find('input').on('change', function(e) &#123; checkCount();&#125;);function checkCount() &#123; var val = $('#count').find('input[type=radio]:checked').val(), $result = $('#count').find('.result').find('span'); if (val == 'on') $result.text(players.length); else $result.text('?');&#125; 솔직히 코드 양이 많지 않아 spaghetti code처럼 보이지 않지만 한 페이지에 이런 기능들이 많다고 가정해봅시다. # The disadvantage of unstructured spaghetti code 코드 양이 한 파일에 너무 많아 가독성이 좋지 않음. 유지보수 하기 어려움. - 기능 구분이 명확히 나누어 있지 않기 때문. 우선 간단히 Object Literal Pattern을 사용하여 코드를 좀 더 효율적으로 개선해보겠습니다. # Object Literal PatternRule 전역 변수 없애기. 관심사 분리하기. DRY Code(Don’t Repeat Yourself) - 반복되는 코드를 사용하지 않기. DOM Cache 하기. 메모리 누수 없애기 - 모든 이벤트는 unbind 될 수 있어야 함. playerCount.js12345(function() &#123; var peoepleCount = &#123;&#125;;&#125;)();console.log(peopleCount); // Uncaught ReferenceError: playerCount is not defined IIFE(Immediately Invoked Function Expressions)를 사용하면 전역변수 오염을 방지할 수 있습니다. playerCount.js1234567891011121314151617181920212223242526272829303132(function() &#123; var playerCount = &#123; players: [], init: function() &#123; this.cacheDom(); this.bindEvents(); this.render(); &#125;, cacheDom: function() &#123; this.$player = $('#player'); this.$count = $('#count'); this.$form = this.$player.find('.form'); this.$input = this.$form.find('input'); this.$button = this.$form.find('button'); this.$ul = this.$player.find('ul'); this.$result = this.$count.find('.result'); this.$radios = this.$count.find('.radios'); this.$span = this.$result.find('span'); this.$radioButton = this.$radios.find('input'); &#125;, bindEvents: function() &#123; this.$button.on('click', this.addPlayer.bind(this)); this.$ul.on('click', 'button', this.deletePlayer.bind(this)); this.$radioButton.on('change', this.checkCount.bind(this)); &#125;, render: function() &#123; this.checkCount(); &#125; &#125;; playerCount.init();&#125;)(); init - peopleCount 객체를 초기화 시킵니다. cacheDom - Dom을 캐싱하기 때문에 성능면에서 효율적입니다. bindEvents - 모든 이벤트는 이 함수안에서 바인드됩니다. render - count 숫자를 렌더링 해줍니다. 주의) Event handler를 등록할 때 bind(this) 사용해야합니다. 아래 예제 코드를 보시겠습니다. playerCount.js1234567891011121314151617181920212223242526(function() &#123; var playerCount = &#123; players: [], init: function() &#123; this.cacheDom(); this.bindEvents(); &#125;, cacheDom: function() &#123; this.$player = $('#player'); this.$form = this.$player.find('.form'); this.$button = this.$form.find('button'); &#125;, bindEvents: function() &#123; this.$button.on('click', this.addPlayer); &#125;, render: function() &#123; console.log('redner') &#125;, addPlayer: function() &#123; console.log(this); // &lt;button type=\"button\"&gt;Add&lt;/button&gt; this.render(); // Uncaught TypeError: this.render is not a function &#125; &#125;; playerCount.init();&#125;)(); Event handler 안에 this는 event target인 button을 가리키고 있기 때문에 addPlayer안에 있는 this는 render method를 찾을 수 없습니다. this의 context는 playerCount를 가리켜야합니다. playerCount.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263(function() &#123; var playerCount = &#123; players: [], init: function() &#123; this.cacheDom(); this.bindEvents(); this.render(); &#125;, cacheDom: function() &#123; this.$player = $('#player'); this.$count = $('#count'); this.$form = this.$player.find('.form'); this.$input = this.$form.find('input'); this.$button = this.$form.find('button'); this.$ul = this.$player.find('ul'); this.$result = this.$count.find('.result'); this.$radios = this.$count.find('.radios'); this.$span = this.$result.find('span'); this.$radioButton = this.$radios.find('input'); &#125;, bindEvents: function() &#123; this.$button.on('click', this.addPlayer.bind(this)); this.$ul.on('click', 'button', this.deletePlayer.bind(this)); this.$radioButton.on('change', this.checkCount.bind(this)); &#125;, render: function() &#123; this.checkCount(); &#125;, addPlayer: function() &#123; var value = this.$input.val(), item = ` &lt;li&gt; &lt;span&gt;$&#123;value&#125;&lt;/span&gt; &lt;button type=\"button\"&gt;Delete&lt;/button&gt; &lt;/li&gt; `; if (!value) &#123; alert('Player 이름을 입력해주세요.'); return; &#125; this.players.push(value); this.$ul.append(item); this.$input.val(''); this.render(); &#125;, deletePlayer: function(e) &#123; var $remove = $(e.target).closest('li'), idx = this.$ul.find('li').index($remove); this.players.splice(idx, 1); $remove.remove(); this.render(); &#125;, checkCount: function() &#123; var val = this.$radios.find('input[type=radio]:checked').val(); val == 'on' ? this.$span.text(this.players.length) : this.$span.text('?'); &#125; &#125; playerCount.init();&#125;)(); 이제 모든 코드가 완성되었고 이전과 동일하게 작동합니다. 자바스크립트 코드만 변경되었습니다. 이전 코드보다 가독성이 좋아졌고 유지보수하기 편해졌습니다.하지만 여기서 한 가지 상황을 더 가정해보겠습니다. 기능들이 더 추가될 예정이며 playerCount에 더 많은 속성과 메서드가 추가될 것입니다. 이런 상황들이 반복적으로 이어지다 보면 파일 하나에 너무 많은 기능이 집약되어 있어 지금처럼 한눈에 파악하기가 쉽지 않습니다.Revealing Module Pattern을 사용하여 player, count 두 객체를 따로 나눠보겠습니다. # Revealing Module PatternRule IIFE라 불리는 즉시 호출 함수를 사용함. 공개해도 지장이 없는 API만 return 시킴. 나머지는 접근가능하지 않도록 비공개 처리해줌. player.js1234567891011121314151617181920212223var player = (function() &#123; var players = []; _render(); function _render() &#123; console.log('render'); &#125; function addPlayer() &#123; &#125; return &#123; addPlayer: addPlayer &#125;&#125;)();console.log(player);/* Outputrender&#123;addPlayer: ƒ&#125;*/ Revealing Module Pattern의 기본 골격입니다. players 변수를 공개해버리면 외부에서 조작을 할 수 있기 때문에 비공개로 해놓아야합니다. player.js1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556var player = (function() &#123; var players = []; // cache Dom var $player = $('#player'), $form = $player.find('.form'), $input = $form.find('input'), $button = $form.find('button'), $ul = $player.find('ul'); // bind events $button.on('click', addPlayer); $ul.on('click', 'button', deletePlayer); _render(); function _render() &#123; count.checkCount(players.length); &#125; function addPlayer() &#123; var value = $input.val(), item = ` &lt;li&gt; &lt;span&gt;$&#123;value&#125;&lt;/span&gt; &lt;button type=\"button\"&gt;Delete&lt;/button&gt; &lt;/li&gt; `; if (!value) &#123; alert('Player 이름을 입력해주세요.'); return; &#125; players.push(value); $ul.append(item); $input.val(''); _render(); &#125; function deletePlayer(e) &#123; var $remove = $(e.target).closest('li'), idx = $ul.find('li').index($remove); players.splice(idx, 1); $remove.remove(); _render(); &#125; return &#123; addPlayer: addPlayer, deletePlayer: deletePlayer &#125;&#125;)(); count.js1234567891011121314151617181920212223242526var count = (function() &#123; var number = 0; // cache Dom var $count = $('#count'), $result = $count.find('.result'), $radios = $count.find('.radios'), $span = $result.find('span'), $radioButton = $radios.find('input'); // bind event $radioButton.on('change', function(e) &#123; checkCount(number) &#125;); function checkCount(newPlayer) &#123; number = newPlayer; var value = $radios.find('input[type=radio]:checked').val(); value == 'on' ? $span.text(number) : $span.text('?'); &#125; return &#123; checkCount: checkCount &#125;&#125;)(); 주의) index.html에 script를 link시킬때 count.js가 player.js보다 위에 있어야됩니다. 그렇지 않으면 Uncaught TypeError: count.checkCount is not a function이라는 에러가 발생합니다. 코드를 분할해 모듈화를 시켜보았습니다. 결과는 이전과 동일합니다. 마지막으로 한가지 상황을 더 가정해보겠습니다. 아래 코드를 보고 설명해보겠습니다. player.js123456789101112var players = [];// (중략)_render();function _render() &#123; count.checkCount(players.length); header.showCount(players.length); footer.displayCount(players.length); sidebar.count(&#123; count: player.length &#125;); // 이런식으로 반복 ... &#125;// (중략) 이런식으로 header, footer, sidebar 이런 세개의 화면을 작업하여 모듈화 작업을 했다고 가정해봅시다. 그리고 count를 이 세군데에 보여주어야합니다. 그래서 player코드 객체 안에 함수들을 호출하였습니다. players 배열을 통해 count를 셀 수 있는데 비공개이기 때문에 다른 객체에서 접근할 수가 없습니다. 그렇다고 계속 이런식으로 호출하면 _render함수 안에 너무 많은 함수 리스트가 쌓입니다. 더 좋은 방법이 없을까요?바로 PubSub Design Pattern을 사용하여 해결해보겠습니다. # PubSub Design PatternPubSub Design Pattern은 발행(publish)/구독(subscribbe) 모델로 알려져 있으며 어떤 대상의 상태값이 변경되었을 경우 이를 감지하고 있는 구독자들은 이것을 인지하고 자동으로 업데이트 해줍니다. 분산 이벤트 시스템을 구현할 때 널리 사용됩니다. subjects - 구독할 이벤트를 저장하는 공간이며 비공개로 처리하였습니다. 비공개 멤버인 이유는 외부에서 조작할 수 없도록 하기 위함입니다. subscribe - 구독할 이벤트를 subjects 객체에 저장합니다. unsubscribe - 구독할 이벤트를 subjects 객체에서 삭제합니다. publish - 저장된 구독이벤트들에게 알림을 보내고 함수를 호출합니다. 간단히 PubSub Design Pattern을 구현해보았습니다.우선 header 하나가 추가된다는 전제하에 코드를 수정해보고 pubsub을 이용하여 구독, 취소, 발행 기능을 추가해보겠습니다. index.html123456789&lt;!-- (중략) --&gt;&lt;!-- 추가된 부분 --&gt;&lt;div id=\"header\"&gt; 인원 &lt;span&gt;&lt;/span&gt;&lt;/div&gt;&lt;hr&gt;&lt;!-- 추가된 부분 --&gt;&lt;div id=\"player\"&gt;&lt;!-- (중략) --&gt; header.js1234567891011121314151617181920var header = (function() &#123; // cache Dom var $header = $('#header'), $span = $header.find('span'); pubsub.subscribe('changedCount', showCount); function showCount(num) &#123; $span.text(num); &#125; function shareData() &#123; return $span.text(); &#125; return &#123; shareData: shareData &#125;&#125;)(); shareData - count에서 카운트 값을 공유할 API 입니다. count.js123456789101112131415161718192021222324252627282930313233343536373839404142var count = (function() &#123; var number = 0; // cache Dom var $count = $('#count'), $result = $count.find('.result'), $radios = $count.find('.radios'), $span = $result.find('span'), $radioButton = $radios.find('input'); // bind event pubsub.subscribe('changedCount', checkCount); $radioButton.on('change', function(e) &#123; var value = $(e.target).val() == 'on' ? 1 : 0; if (value) &#123; resume(); &#125; else &#123; destroy(); &#125; &#125;); function checkCount(newPlayer) &#123; number = newPlayer; var value = $radios.find('input[type=radio]:checked').val(); value == 'on' ? $span.text(number) : $span.text('?'); &#125; /* pubsub event */ function resume() &#123; number = header.shareData(); $span.text(number); pubsub.subscribe('changedCount', checkCount); &#125; function destroy() &#123; pubsub.unsubscribe('changedCount', checkCount); $span.text('?'); &#125;&#125;)(); pubsub을 이용했기 때문에 굳이 외부로 checkCount를 공개 API롤 설정하지 않아도 됩니다. 구독취소(unsubscribe)를 하면 다시 구독하게 되었을 때 기존의 있던 값을 노출시키기 때문에 header.shareData() 호출하여 카운트값을 공유합니다. player.js12345// (중략)function _render() &#123; pubsub.publish('changedCount', players.length);&#125;// (중략) 발행 기능을 추가함으로써 기존 모듈 하나하나를 추가할 때마다 _render 함수안에서 호출하지 않아도 됩니다. 코드가 훨씬 깔끔해졌습니다. 각 모듈들을 pubsub.js -&gt; count.js -&gt; header.js -&gt; player.js 순서로 불러와야 오류없이 작동됩니다.제대로 작동하는지 한번 확인해보겠습니다. Wrap-up자바스크립트 디자인 패턴을 적용하게 되면은 규모가 큰 어플리케이션에서 좀 더 생산적이고 효율적으로 작업을 할 수 있습니다. 포스팅을 보시고 수정 혹은 잘못된 부분은 댓글 부탁드립니다. ReferenceStackoverflow - How to avoid memory leaks from jQuery?Observer vs Pub-Sub pattern Publisher->Event Channel: Publish Event(발행) Event Channel->Subscriber: Fire Event(발행 알림) Subscriber-->Event Channel: Subscriber(구독 신청){\"scale\":1,\"line-width\":2,\"line-length\":50,\"text-margin\":10,\"font-size\":12,\"theme\":\"simple\"} var code = document.getElementById(\"sequence-0-code\").value; var options = JSON.parse(decodeURIComponent(document.getElementById(\"sequence-0-options\").value)); var diagram = Diagram.parse(code); diagram.drawSVG(\"sequence-0\", options);","categories":[{"name":"Front-end","slug":"Front-end","permalink":"http://jason0853.github.io/categories/Front-end/"},{"name":"Javascript","slug":"Front-end/Javascript","permalink":"http://jason0853.github.io/categories/Front-end/Javascript/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://jason0853.github.io/tags/Javascript/"},{"name":"Design Pattern","slug":"Design-Pattern","permalink":"http://jason0853.github.io/tags/Design-Pattern/"},{"name":"jQuery","slug":"jQuery","permalink":"http://jason0853.github.io/tags/jQuery/"}]},{"title":"merge vs rebase","slug":"merge-vs-rebase","date":"2018-01-19T07:52:11.000Z","updated":"2019-05-18T06:10:55.389Z","comments":true,"path":"2018/01/19/merge-vs-rebase/","link":"","permalink":"http://jason0853.github.io/2018/01/19/merge-vs-rebase/","excerpt":"","text":"프로젝트 결과물도 중요하지만 작업 과정을 기록하는 일 또한 협업 업무에 있어서 중요하다고 생각합니다. 그래서 히스토리를 어떻게 정리할 것인가에 대해서 다뤄볼 예정입니다. 보통은 각 기능마다 브랜치를 생성해서 작업이 끝난 뒤 다른 브랜치로 병합하는 과정을 진행합니다. 이렇게 병합을 진행하는데 있어서 git에는 merge와 rebase가 있습니다. 이 두 차이를 알아보고 어떤 상황에서 써야되는지 알아봅시다. 현재 위 상황처럼 test브랜치와 master브랜치가 엇갈리게 만들어놓고 병합을 한번 진행해보겠습니다. # Merge 1$ git merge 'branch name' master 브랜치에서 git merge test한 커밋 로그입니다. 로그에서 보듯이 병렬로 작업된 구조가 그대로 보존되면서 Merge branch ‘test’라는 새로운 커밋 로그가 맨 위에 있습니다. 작업한 과정을 고스란히 보여줍니다. 두 브랜치의 최종결과만을 가지고 합칩니다. 이제 다시 merge 전으로 돌린 이후 이전과 똑같은 상황에서 rebase 작업을 진행해보겠습니다. # Rebase 1$ git rebase 'branch name' 왼쪽 터밀널은 test 브랜치에서 git rebase master를 한 커밋로그이며 오른쪽 터미널은 rebase 작업이 끝난 뒤 master 브랜치에서 git merge test를 한 커밋로그입니다. 로그를 살펴보면 merge한 로그와 달리 히스토리가 선형으로 보기 좋게 나옵니다. rebase는 브랜치의 변경사항을 순서대로 다른 브랜치에 적용하면서 합칩니다. 지금까지는 각 브랜치에서 다른 파일을 작업했기 때문에 충돌이 나지 않고 auto-merging이 잘 되었습니다.이번에는 충돌 상황을 고의로 만든 이후에 rebase 작업을 해나가며 충돌을 해결하는 작업을 진행해보겠습니다. 파일 하나만을 가지고 브랜치를 바꿔가며 작업하여 로그를 보여준 모습입니다. test 브랜치에서 rebase 작업을 하였습니다.하지만 CONFLICT(content): Merge conflict in index.html라는 메세지가 보입니다.충돌을 해결해줍시다. 충돌을 해결한 뒤 파일을 staging area로 옮깁니다. git 상태 체크를 다시 해봅니다.all conflicts fixed: run “git rebase –continue”라는 메세지가 보입니다.충돌이 더 이상 없으면 Auto-merging 작업이 충돌없이 잘 진행됩니다. 12$ git add 'file name'$ git rebase --continue mark resolution은 충돌을 해결했으면 git에게 알려주어야 다음 rebase 작업을 진행할 수 있습니다.ex) git add index.html continue 옵션과 rebase 작업을 하면 기존 작업을 이어서 작업해줍니다. Wrap-up개인적으로는 로컬 브랜치에서 병합을 진행할 때 히스토리를 깔끔하게 보기 위해서 rebase를 즐겨쓰는 편이기는 하지만 merge 작업 또한 히스토리를 변경하지 않고 로그가 남기 때문에 프로젝트 회고 시간을 가질 때 좋은 것 같습니다. 각각 장단점이 있기 때문에 어떤 것이 우월하다고 말하기 곤란하며 각자의 상황과 판단에 맞춰서 쓰시길 추천합니다. ReferenceGit documentation - Rebase 하기","categories":[{"name":"Ops","slug":"Ops","permalink":"http://jason0853.github.io/categories/Ops/"},{"name":"Git","slug":"Ops/Git","permalink":"http://jason0853.github.io/categories/Ops/Git/"}],"tags":[{"name":"git","slug":"git","permalink":"http://jason0853.github.io/tags/git/"}]},{"title":"fetch vs pull","slug":"fetch-vs-pull","date":"2018-01-16T04:27:40.000Z","updated":"2019-05-18T06:10:55.389Z","comments":true,"path":"2018/01/16/fetch-vs-pull/","link":"","permalink":"http://jason0853.github.io/2018/01/16/fetch-vs-pull/","excerpt":"","text":"회사에서 Git 작업을 하면서 원격저장소로부터 소스를 동기화시키기 위해서 항상 pull을 사용했었는데 fetch라는 기능도 있다는 것을 팀원을 통해 알게 되었습니다. 그럼 이 둘의 미묘한 차이를 한 번 다뤄보겠습니다. 12$ git fetch$ git pull git fetch - 원격저장소로부터 소스를 로컬저장소로 가져오지만 merge 작업을 하지 않습니다. git pull - 원격저장소로부터 소스를 로컬저장소로 가져와서 working directory에 있는 소스와 함께 merge 작업을 진행합니다. 1$ git merge 'remote branch` git fetch를 한 이후 소스를 working directory와 병합하고 싶으면 merge 작업을 진행해줍니다.ex) git merge origin/master Wrap-up결국 git pull = git fetch + git merge를 합한 결과라고 보면 될 것 같습니다. ReferenceGit documentation - 리모트 브랜치 working directory->staging area: git add staging area->local repo: git commit local repo->remote repo: git push remote repo-->local repo: git fetch remote repo-->working directory: git pull{\"scale\":1,\"line-width\":2,\"line-length\":50,\"text-margin\":10,\"font-size\":12,\"theme\":\"simple\"} var code = document.getElementById(\"sequence-0-code\").value; var options = JSON.parse(decodeURIComponent(document.getElementById(\"sequence-0-options\").value)); var diagram = Diagram.parse(code); diagram.drawSVG(\"sequence-0\", options);","categories":[{"name":"Ops","slug":"Ops","permalink":"http://jason0853.github.io/categories/Ops/"},{"name":"Git","slug":"Ops/Git","permalink":"http://jason0853.github.io/categories/Ops/Git/"}],"tags":[{"name":"git","slug":"git","permalink":"http://jason0853.github.io/tags/git/"}]},{"title":"Useful features on Git","slug":"Useful-features-on-Git","date":"2018-01-15T06:56:46.000Z","updated":"2019-05-18T06:10:55.388Z","comments":true,"path":"2018/01/15/Useful-features-on-Git/","link":"","permalink":"http://jason0853.github.io/2018/01/15/Useful-features-on-Git/","excerpt":"","text":"이번 포스팅은 Git을 사용하면서 필자가 자주 사용하는 유용한 기능들에 대해서 살펴보겠습니다. # Stash123456$ git stash save 'stash message'$ git stash apply stash@&#123;index&#125;$ git stash pop$ git stash drop stash@&#123;index&#125;$ git stash clear$ git stash list git stash 특징 unstaged files들은 백업해두면서 working directory는 최신 커밋상태로 돌아갑니다. untracked files들은 백업되지 않습니다. 브랜치를 변경해도 stash는 공유됩니다. pop은 apply와 달리 적용되면서 stash에서 제거됩니다. 주로 커밋작업할 준비가 아직 되어 있지 않을때 stash를 이용하여 백업해둡니다. # Cherry-pick1$ git cherry-pick 'hash' 다른 브랜치의 커밋 내역을 다 복사해오지 않고 특정 커밋만 가져오고 싶은 경우 사용됩니다. # TagGit 태그는 Lightweight tag와 Annotated tag로 분류되어 있습니다. 123$ git tag 'tag name' 'hash or branch name'$ git tag$ git tag -d 'tag name' 태그 이외에 다른 정보를 저장할 필요가 없다면 위와 같이 아무 옵션 없이 명령어를 실행시키면 됩니다. 위와 같은 방법을 Lightweight tag라 부릅니다. 태그를 이용하여 git checkout ‘tag name’을 이용하면 태그가 위치한 커밋 소스로 이동합니다. 12$ git tag -a 'tag name' -m 'tag message'$ git tag -v 'tag name' a옵션은 annotated의 약자로 Annotated tag를 지정하는 것입니다. git tag -v - 위 그림의 빨강 박스에서 확인할 수 있듯이 태그를 생성한 사람의 username, email, date, tag message가 보여집니다. 1$ git push --tags tag를 원격저장소에도 반영하기 위해서는 tags옵션과 함께 푸쉬 작업을 해줍니다. 소프트웨어 버전을 작성할 때 어떤 기준으로 해서 작성을 할 것인가에 대해 고민하신다면 이 사이트를 참고바랍니다. Wrap-upGit 작업을 하면서 stash, cherry-pick, tag를 상황에 맞게 적절히 이용하면서 사용하시길 바랍니다. ReferenceGit documentation - 태그","categories":[{"name":"Ops","slug":"Ops","permalink":"http://jason0853.github.io/categories/Ops/"},{"name":"Git","slug":"Ops/Git","permalink":"http://jason0853.github.io/categories/Ops/Git/"}],"tags":[{"name":"git","slug":"git","permalink":"http://jason0853.github.io/tags/git/"}]},{"title":"OOP & Inheritance","slug":"OOP-Inheritance","date":"2018-01-10T14:02:11.000Z","updated":"2019-05-18T06:10:55.387Z","comments":true,"path":"2018/01/10/OOP-Inheritance/","link":"","permalink":"http://jason0853.github.io/2018/01/10/OOP-Inheritance/","excerpt":"","text":"OOP란 Object-oriented programming(객체지향 프로그래밍)이라고 불리며 대규모 어플리케이션을 제작할 때 보다 유연하고 유지보수하기 높은 프로그래밍 패턴입니다. 각각의 기능을 모듈화를 함으로써 코드 재사용할 수 있는 특징과 객체의 독립성을 유지시켜줍니다. 모듈을 재활용함으로써 하드웨어 처리량을 획기적으로 줄일 수 있습니다. 자바스크립트에서 OOP를 구현하기 위해 두 가지 Inheritance(상속) 방법에 대해서 알아보겠습니다. # Classical Inheritance12345678910111213141516171819202122232425262728293031323334353637383940414243444546let Human = function(firstname, lastname) &#123; this._firstname = firstname; this._lastname = lastname;&#125;;Human.prototype.greet = function() &#123; console.log(`Hello, I'm $&#123;this._firstname&#125; $&#123;this._lastname&#125;.`);&#125;let Player = function(firstname, lastname, sport) &#123; Human.call(this, firstname, lastname); this._sport = sport;&#125;;Player.prototype = Object.create(Human.prototype);Player.prototype.constructor = Player;Player.prototype.greet = function() &#123; console.log(`Nice to meet you, I'm $&#123;this._firstname&#125; $&#123;this._lastname&#125;.`);&#125;;Player.prototype.play = function() &#123; console.log(`I play $&#123;this._sport&#125;.`);&#125;;let Guard = function(firstname, lastname, sport, skill) &#123; /** * [...arguments].slice(0, 3) * output: [firstname, lastname, sport] */ Player.apply(this, [...arguments].slice(0, 3)); this._skill = skill;&#125;;Guard.prototype = Object.create(Player.prototype);Guard.prototype.constructor = Guard;Guard.prototype.showoff = function() &#123; console.log(`I'm good at $&#123;this._skill&#125;`);&#125;;let kyrie = new Guard('Kyrie', 'Irving', 'basketball', 'dribble');kyrie.greet(); // Hello, I'm Kyrie Irving.kyrie.play(); // I play basketball.kyrie.showoff(); // I play 생성자함수를 정의할 때 함수선언식이 아닌 익명함수로 정의하였습니다.함수선언식 같은 경우 자바스크립트 인터프리터가 스크립트가 로딩되는 시점에 바로 초기화하고 VO(Variable Object)에 저장되기 때문에 위치와 상관없이 호출됩니다. 그렇기 때문에 VO에 함수선언식이 많으면 VO에 저장되는 코드가 많게 되어 어플리케이션 응답속도를 저하시킵니다. 하지만 익명함수는 VO에 저장되지 않고 runtime시에 실행됩니다. call과 apply 함수를 이용하여 현재 생성자 context로 바인딩합니다. Object.create()을 이용하지 않고 prototype을 그대로 상속하였을 경우 prototype에 추가한 greet함수도 같이 업데이트 되기 때문에 값이 변경되버립니다. constructor 설정은 필수는 아니지만 내부적으로 설정되지 않는 부분들을 수정해주는 습관을 주는 것이 도움이 됩니다. # Prototypal Pattern123456789101112131415161718let employee = &#123; company: 'Facebook', work: function() &#123; console.log(`I work for $&#123;this.company&#125;`); &#125;, master: function() &#123; console.log(this.skill); &#125;&#125;;let webEngineer = Object.create(employee);webEngineer.skill = 'HTML, CSS, Javascript';let frontendEngineer = Object.create(webEngineer);frontendEngineer.skill = 'React, Redux, React-Native';frontendEngineer.master = function() &#123; console.log(`Mastered $&#123;this.skill&#125;`);&#125;; 기본적으로 Prototypal Pattern 은 모든 것이 객체입니다. object literal로 시작한 다음 객체를 상속을 하려면 Object.create()을 사용합니다. Classical Inheritance보다 상속을 구현하기가 더 쉬우며 직관적입니다. Object.create()는 ECMASCRIPT5 스펙으로 하위브라우저(IE8이하)는 지원하지 않습니다. 아래코드는 위코드랑 동일하며 좀 더 보안된 코드입니다. 123456789101112131415161718192021222324let employee = &#123; company: 'Facebook', create: function(values) &#123; let instance = Object.create(this); Object.keys(values).forEach(function(key) &#123; instance[key] = values[key]; &#125;); return instance; &#125;, work: function() &#123; console.log(`I work for $&#123;this.company&#125;`); &#125;, master: function() &#123; console.log(this.skill); &#125;&#125;;let webEngineer = employee.create(&#123; skill: 'html, css, javascript' &#125;);let frontendEngineer = webEngineer.create(&#123; skill: 'React, Redux, React-Native', master: function() &#123; console.log(`Mastered $&#123;this.skill&#125;`); &#125;&#125;); create 메서드를 추가함으로써 상속한 다음에 굳이 따로 property를 추가하지 않아도 됩니다. Wrap-up객체지향 프로그래밍을 하기에 앞서 자바스크립트 프로토타입 기반 상속 모델을 이해하는 것이 중요합니다. 또한 프로토타입 체인의 걸친 속성 검색으로 인해 성능상에 이슈가 생길 수 있으니 유의하시기 바랍니다. ReferenceMozilla - 객체지향 자바스크립트 소개StackOverflow - Why is it necessary to set the prototype constructor?Mozilla - Object.create()","categories":[{"name":"Front-end","slug":"Front-end","permalink":"http://jason0853.github.io/categories/Front-end/"},{"name":"Javascript","slug":"Front-end/Javascript","permalink":"http://jason0853.github.io/categories/Front-end/Javascript/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://jason0853.github.io/tags/Javascript/"}]},{"title":"Object creation","slug":"Object-creation","date":"2018-01-09T13:45:26.000Z","updated":"2019-05-18T06:10:55.386Z","comments":true,"path":"2018/01/09/Object-creation/","link":"","permalink":"http://jason0853.github.io/2018/01/09/Object-creation/","excerpt":"","text":"최근 Javascript를 기초부터 다시 공부하고 있는 와중에 블로그에도 문서화 시키면 좋을 것 같아서 공부한 내용을 정리해보기로 했습니다. 이 포스팅을 보시면서 오타가 있거나 잘못된 내용이 있다면 댓글 부탁드립니다. # bind and this1234567891011let player = &#123; sport: 'basketball', play: function() &#123; console.log(this.sport); &#125;&#125;;player.play(); // basketballlet playFunction = player.play;playFunction(); // undefined undefined가 로그에 찍히는 이유는 this 키워드를 통해 context에 접근할 수 있는데 playFunction은 단순히 함수입니다. 10번째 줄 코드는 아래코드와 동일합니다. 123let playFunction = function() &#123; console.log(this.sport);&#125;; 이제 bind함수를 이용하여 this가 가리키고 있는 context를 변경해보겠습니다. 123456789101112let player = &#123; sport: 'basketball', play: function() &#123; console.log(this.sport); &#125;&#125;;player.play(); // basketballlet playFunction = player.play;let playFunctionBound = playFunction.bind(player);playFunctionBound(); // basketball bind()의 파라미터에 참조해야할 객체인 player를 인자로 전달해주어 this는 속성에 접근할 수 있게 됩니다. 12345678910function play() &#123; console.log(this.sport);&#125;let player = &#123; sport: 'basketball'&#125;;let playBound = play.bind(player);playBound(); // basketball 이번에는 함수를 player 객체로부터 분리해놓고 설명해보겠습니다. bind 함수를 사용하기 이전에 코드를 살펴보면은 play 함수 안에 있는 this는 window 객체(웹 브라우저) 혹은 global 전역 객체(node.js)를 가리킵니다. 그렇기 때문에 this가 player 객체를 바라보도록 컨텍스트를 변경해야합니다. 12345678910111213141516let play = function() &#123; console.log(this.sport);&#125;let player = &#123; do: play, sport: 'basketball'&#125;;let anotherPlayer = &#123; swim: player.do, sport: 'swimming'&#125;;player.do(); // basketballanotherPlayer.swim(); // swimming anotherPlayer 객체 하나를 더 생성해 보았습니다. 각 객체의 do, swim 속성에 play 함수가 복사되면서 this가 가리키는 컨텍스트는 각 객체 자신입니다. 만약 bind() 함수를 사용하지 않는다면 this가 가리키는 객체는 button 태그를 가리킵니다. # Prototype basic보통 상속을 할때 클래스를 사용하는데 익숙합니다. 하지만 자바스크립트는 프로토타입(prototype)을 사용하여 상속을 구현합니다. Object.setPrototypeOf(obj, prototype); 를 이용하여 프로토타입을 설정해보겠습니다. 1234567891011121314151617181920212223242526272829function say() &#123; console.log(this.greet);&#125;let person = &#123; say // === say: say 와 동일합니다. es6 syntax&#125;;let student = &#123; greet: 'Hello'&#125;;let soldier = &#123; greet: 'Hello, sir'&#125;;let strongSoldier = &#123; shout: function() &#123; console.log(this.greet.toUpperCase()); &#125;&#125;;Object.setPrototypeOf(student, person);Object.setPrototypeOf(soldier, person);Object.setPrototypeOf(strongSoldier, soldier);student.say(); // Hellosoldier.say(); // Hello, sirstrongSoldier.shout(); // HELLO, SIR student, soldier객체는 프로토타입을 설정할 객체이며 person객체가 가지고 있는 say함수는 공통 메서드로 사용할 것이기 때문에 새로운 객체의 프로토타입으로 설정하였습니다. strongSoldier 객체에 프로토타입을 설정해주지 않으면 shout 함수안에 있는 this는 greet이라는 속성을 가지고 있지 않기 때문에 에러가 발생하게 됩니다. # The ‘new’ keyword자바스크립트에서 new 키워드가 함수에 적용되었을 때 어떻게 작동되는지 살펴보겠습니다. 1234567891011121314151617181920212223242526272829function Person(name, age) &#123; this.name = name; this.age = age;&#125;Person.prototype.introduce = function() &#123; console.log('My name is ' + this.name + '. I\\'m ' + this.age);&#125;// new 키워드의 역할function create(ctor) &#123; // 1. 빈 Object 생성 let obj = &#123;&#125;; // 2. prototype 설정 Object.setPrototypeOf(obj, ctor.prototype); // 3. this 키워드는 생성자 함수를 가리키도록 설정 ctor.apply(obj, [...arguments].slice(1)); // ... 전개연산자(spread operator) es6 syntax // 4. 가공된 object 리턴 return obj;&#125;let jason = create(Person, 'Jason', 32);let jane = new Person('Jane', 28);jason.introduce(); // My name is Jason I'm 32jane.introduce(); // My name is Jane I'm 32 new의 역할 : create함수와 동일 빈 object를 생성합니다. prototype을 설정해줍니다. this 키워드가 constructor 함수를 가리키도록 합니다. 생성한 object를 return 해줍니다. arguments 객체는 Array가 아니기 때문에 배열 행태로 변경해줘야합니다. […arguments] es6 문법을 이용하여 배열형태로 변경하였습니다. […arguments] instanceof Array를 로그에 출력해보면 true를 반환합니다. slice메서드를 사용한 이유는 Person을 제외한 나머지 인자값들을 리턴해주어야하기 때문입니다. # __proto__ vs prototype1234567891011121314let car = &#123; door: 4&#125;;let sportCar = &#123; boost: true&#125;;Object.setPrototypeOf(car, sportCar);car.__proto__.name = 'Ferrari';car.__proto__; // &#123; boost: true, name: \"Ferrari\" &#125;car.prototype; // undefined 프로토타입을 설정할 객체 - car 객체의 새로운 프로토타입 - sportCar __proto__ 속성은 현재 객체가 프로토타입 체인에서 조회를 수행할 때 실제로 사용할 객체를 가리킵니다. 123456789function Person() &#123;&#125;Person.prototype.say = 'Hello';let student = new Person();student.say; // Hellostudent.__proto__; // &#123; say: \"Hello\", constructor: ƒ &#125;student.__proto__ === Person.prototype // true prototype은 함수에만 존재하며 해당 객체를 생성자로 사용하려는 경우에 사용됩니다. # Object.create()Object.create() 메서드는 새로운 객체와 함께 지정된 프로토타입 객체와 속성을 갖습니다. 12345678910const dog = &#123; bark: function() &#123; console.log(this.sound); &#125;&#125;;const sam = Object.create(dog);sam.sound = 'bow-wow'.toUpperCase();sam.bark(); // BOW-WOWdog.isPrototypeOf(sam); // true dog객체가 const(상수)로 설정되어 있지만 객체의 속성은 언제든지 변경 및 추가할 수 있습니다. 12345678910111213const dog = &#123; init: function(sound) &#123; this.sound = sound; &#125;, bark: function() &#123; console.log(this.sound); &#125;&#125;;const sam = Object.create(dog);sam.init('bow-wow'.toUpperCase());sam.bark(); // BOW-WOWdog.isPrototypeOf(sam); // true init함수는 생성자 함수와 같습니다. # class keywordclass 키워드는 ECMASCRIPT6에 추가된 기능이며 앞서 배웠던 prototype기반의 상속보다 좀 더 직관적이고 명료하게 사용할 수 있습니다. 하지만 저희가 일반적으로 알고 있는 자바의 클래스처럼 새로운 객체지향 상속 모델은 아닙니다. 123456789101112131415161718192021class Human &#123; constructor(name) &#123; this._name = name; &#125; hello() &#123; return `Hello $&#123;this._name&#125;`; // `$&#123;&#125;` Template literal - es6 문법 &#125;&#125;class Teacher extends Human &#123; constructor(name) &#123; super(name); &#125;&#125;let tom = new Human('Tom');let john = new Teacher('John');tom.hello('Tom'); // Tomjohn.hello('John'); // John constructor - 객체를 생성하고 초기화하기 위한 특수한 메서드이며 class내에서 오직 한번만 사용할 수 있습니다. super - 부모 클래스의 constructor를 호출하기 위해 사용됩니다. Wrap-up자바스크립트 객체에 대해 한번 정리하고 나니 기존에 이해가 가지 않았거나 놓친 부분들이 보완된 느낌입니다. 포스팅에 대한 질문이나 잘못된 내용이 있다면 댓글로 피드백 바랍니다. ReferenceMozilla - ObjectMozilla - Object.setPrototypeOf()Mozilla - Object.create()","categories":[{"name":"Front-end","slug":"Front-end","permalink":"http://jason0853.github.io/categories/Front-end/"},{"name":"Javascript","slug":"Front-end/Javascript","permalink":"http://jason0853.github.io/categories/Front-end/Javascript/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://jason0853.github.io/tags/Javascript/"}]},{"title":"Fixing common mistakes","slug":"Fixing-common-mistakes","date":"2018-01-04T07:25:06.000Z","updated":"2019-05-18T06:10:55.386Z","comments":true,"path":"2018/01/04/Fixing-common-mistakes/","link":"","permalink":"http://jason0853.github.io/2018/01/04/Fixing-common-mistakes/","excerpt":"","text":"이번 포스팅은 git을 하면서 사소한 실수를 했을때 대처하는 방법에 대해서 정리해보겠습니다.우선 git 연습을 하기 위한 빈 디렉토리와 파일을 만들고 커밋을 진행해주세요.혹시 git을 처음 사용하시는 분들은 지난번 포스팅을 참고해주시기 바랍니다. # Restore code index.html12345678910111213&lt;html&gt; &lt;head&gt;&lt;/head&gt; &lt;body&gt; 지워야 될 텍스트 지워야 될 텍스트 지워야 될 텍스트 지워야 될 텍스트 지워야 될 텍스트 지워야 될 텍스트 지워야 될 텍스트 ... &lt;/body&gt;&lt;/html&gt; 12$ git diff$ git checkout 'filename' git diff 명령어는 파일의 변경된 코드를 확인할 수 있습니다. 터미널 캡처 오른쪽을 확인해보면 새로 추가된 코드는 녹색으로 표시되어 나옵니다. git checkout index.html을 실행시키면 변경되기 전의 코드로 돌아갑니다. # Change a commit message 1$ git commit --amend -m 'message' 커밋 메세지에 오타를 수정하고 싶거나 변경하고 싶은 경우 다른 커밋 작업을 진행하기 직전에 바로 amend옵션과 함께 명령어를 실행시키면 메세지가 수정됩니다. # Reset 1234$ git reset --soft 'hash'$ git reset --mixed 'hash'$ git reset --hard 'hash'$ git clean -df 커밋로그 보시면 unique 값들이 나열되어 있는데 이것을 hash(해쉬)라고 부릅니다. git reset 명령어를 사용할 때 hash[약7~8자 정도 copy and paste]를 통하여 원하는 커밋 로그 상태로 돌아갈 수 있습니다. soft 옵션을 통하여 staging area로 돌아갑니다. mixed 옵션은 working directory로 돌아갑니다.주의해서 봐야할 점은 index.html 파일은 이미 이전에 커밋을 했던 파일이며 script.js 파일은 새로 만들어져서 untracked files로 분류되어 있습니다. hard 옵션은 변경된 코드는 제거되고 이전 커밋에 저장해놓았던 코드 상태로 되돌아갑니다.대신 untracked files로 분류된 파일들은 영향을 받지 않습니다. git clean -df - undrecked file들을 삭제해줍니다. 1$ git reset --hard HEAD~1 최신 커밋 로그 메세지를 지우고 싶은 경우 HEAD~1을 추가하면 됩니다.ex)예를 들어 최신 커밋 로그 2개를 지우고 싶은 경우는 HEAD~2을 추가하면 됩니다. 만약 원격저장소에 저장되어 있는 커밋 로그까지 삭제하고 싶다면 git push origin HEAD –force 명령어를 실행하시면 됩니다. # Revert 1$ git revert 'hash'...'hash' 이미 push까지 작업한 커밋을 되돌리고 싶을때는 revert를 사용합니다.revert작업할 때 최신 커밋 로그부터 차례대로 작업하는 것을 권고드립니다. conflict를 최소화하기 위해서입니다. 하나의 커밋만 revert하고 싶은 경우는 git revert ‘hash’를 하시면 됩니다. 여러 커밋을 하고 싶은 경우는 ‘hash’…’hash’ 되돌아가고 싶은 커밋 시점부터 마지막 커밋 시점까지를 뜻합니다. Wrap-up여기까지 Git을 사용하며 실수에 대처하는 방법에 대해서 알아보았습니다. 많은 도움이 되시길 바랍니다. ReferenceStackOverflow - Delete commits from a branch in Gitlocal repo-->staging area: git reset --soft staging area-->working directory: git reset --mixed Note right of working directory: git reset --hard\\n git clean -df{\"scale\":1,\"line-width\":2,\"line-length\":50,\"text-margin\":10,\"font-size\":12,\"theme\":\"simple\"} var code = document.getElementById(\"sequence-0-code\").value; var options = JSON.parse(decodeURIComponent(document.getElementById(\"sequence-0-options\").value)); var diagram = Diagram.parse(code); diagram.drawSVG(\"sequence-0\", options);","categories":[{"name":"Ops","slug":"Ops","permalink":"http://jason0853.github.io/categories/Ops/"},{"name":"Git","slug":"Ops/Git","permalink":"http://jason0853.github.io/categories/Ops/Git/"}],"tags":[{"name":"git","slug":"git","permalink":"http://jason0853.github.io/tags/git/"}]},{"title":"Git basic","slug":"Git-basic","date":"2017-12-16T13:09:59.000Z","updated":"2019-05-18T06:10:55.386Z","comments":true,"path":"2017/12/16/Git-basic/","link":"","permalink":"http://jason0853.github.io/2017/12/16/Git-basic/","excerpt":"","text":"프로젝트를 시작하게 되면 여러 개발자들과 협업을 진행하게 됩니다. 특히 협업할 때 source 관리를 해야되는데 가장 많이 사용하는 git에 대해 한번 살펴보겠습니다. 이번 포스팅에서는 가장 빈번하게 사용되는 명령어와 git의 흐름 상황을 요약 정리해보겠습니다. Quick Start# Check version1$ git --version git이 제대로 설치되어 있는지 확인하려면 version 체크를 하시면 됩니다. # Set config values123$ git config --global user.name 'username'$ git config --global user.email 'your email'$ git config --list global 옵션을 주어 git의 사용자와 이메일을 셋팅해 줄 수 있습니다. list 옵션을 통하여 셋팅된 목록을 볼 수 있습니다. 만약 global property를 삭제하고 싶은 경우는 unset 옵션을 추가하여 해당 property를 지우시면 됩니다.ex)git config –global –unset user.name # Initialize a repository1$ git init 프로젝트 root 디렉토리에서 init 명령어를 통하여 초기화 시킨 이후 .git이라는 파일이 생성됩니다. # Create a gitignore file root 디렉토리에 .gitignore 파일을 만듭니다. .gitignore 파일은 git을 통해 소스관리를 할 필요 없는 파일이나 폴더명을 써주시면 됩니다. # Common workflow 각각의 명령어를 실행하면 어떤 상태인지를 disagram으로 정리해보았습니다. 그럼 위에 나온 명령어들과 함께 간단한 실습을 한번 진행해보겠습니다. 1$ git status 우선 git-test 라는 프로젝트 폴더 하나를 만들고 앞서 얘기했던 git init 작업과 .gitignore 파일을 생성하였습니다. git status는 파일의 현재 상태를 알려줍니다. commit을 한번도 진행하지 않았기 때문에 새로 생성된 file은 Untracked files로 분류되어 있습니다. 12$ git add -A$ git commit -m 'your commit message' 현재는 .gitignore 파일 하나만 있어서 git add .gitignore 이런식으로 명령어를 입력해도 되지만 여러 파일들을 한번에 staging area로 옮기는 작업을 할려면 간단하게 A 옵션을 주면 됩니다. staging area에 잘 옮겨졌는지 체크해보려면 git status 명령어를 실행시킵니다. 아까와 다르게 녹색 컬러로 변경된 .gitignore 파일을 확인할 수 있습니다. commit 명령어를 통하여 staging area에서 local repository로 옮기고 git 상태를 체크해봅니다. 터미널 캡쳐 마지막 부분을 보면은 nothing to commit 이라고 나옵니다. 더 이상 커밋 작업을 할게 없으므로 push 작업을 할 차례입니다. 123$ git remote add origin 'your remote url'$ git remote -v$ git push -u origin master push 작업을 하기 위해서는 원격저장소를 추가해야합니다. 필자는 github를 사용하여 원격저장소를 만들었지만 Bitbucket, gitlab 등을 사용하셔도 됩니다. remote url을 추가한 뒤에 v 옵션을 통해 단축이름과 url을 함께 볼 수 있습니다. u 옵션을 추가하면은 push 작업 및 pull 작업을 진행할때 origin master를 명령어와 함께 실행시키지 않아도 됩니다.ex)git push / git pull 작업이 끝난 뒤 자신의 원격저장소에서 확인해보면 .gitignore 파일이 저장되어 있습니다.하지만 보통 회사에서 일할 때는 master 브랜치에서 작업하는 경우는 거의 없습니다. 다수의 개발자들과 서로 협업을 해야하므로 각각 브랜치(branch)를 생성해서 이동(checkout)한 다음에 코딩작업을 진행합니다. 코딩작업이 끝난 이후에는 각 개발자들의 작업내역을 master 브랜치로 병합(merge)시킵니다.그럼 이어서 한번 진행해보겠습니다. .gitignore123node_modulesdist.env index.html12345&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt;&lt;/head&gt; &lt;body&gt;&lt;/body&gt;&lt;/html&gt; 123$ git branch 'new branch name'$ git branch$ git checkout 'branch name' 필자는 test라는 새로운 브랜치를 하나 생성해서 작업을 진행을 했습니다. 새로운 브랜치를 만들고 나서 제대로 생성되었는지 확인하려면 git branch 명령어를 실행시켜줍니다. test 브랜치로 이동하기 위해서 git checkout test 명령어를 실행시켜줍니다.이 때 기존 master(local) 브랜치에 있는 source가 test 브랜치로 복사됩니다. git status로 파일의 체크 상태를 체크해보면 .gitignore 파일은 Untracked files로 분류되어 있지 않습니다.그 이유는 이미 commit한 files들은 git에 의해 tracking이 되고 있기 때문입니다. 반대로 index.html은 새로 생성한 다음에 commit 작업을 한번도 진행하지 않았기 때문에 Untracked files로 분류되어 있는 것입니다. 1$ git branch -a add, commit, push 작업을 순서대로 진행합니다. 원격저장소에서 test 브랜치로 바꾼 다음 확인하면 위 그림과 같이 푸쉬한 파일들과 commit message들을 확인할 수 있습니다. a 옵션과 함께 git branch 명령어를 실행시켜면 local 브랜치와 remote 브랜치 둘 다 확인할 수 있습니다. test 브랜치에서의 작업이 다 끝났으므로 merge 작업을 진행해보겠습니다. 123$ git pull$ git branch --no-merged$ git merge 'branch name' master 브랜치에서 test 브랜치를 병합시킬 것이기 때문에 checkout을 통해 master 브랜치로 이동했습니다.이미 만들어진 브랜치로 checkout 작업을 진행한 경우에는 source의 변경사항이 없습니다. 브랜치를 변경한 이후에 pull 작업을 하는 이유는 remote master 브랜치와 local master 브랜치의 source를 동기화시키기 위해서입니다.항상 브랜치를 checkout한 경우에는 conflict를 최소화하기 위해 원격 작업 내역을 병합한 다음 자신의 작업내역을 진행하는 습관을 들이는 것이 좋습니다. no-merged 옵션을 통하여 병합하지 않은 branch list를 확인합니다. test 브랜치를 master 브랜치로 병합시킵니다. 이때 Fast-forward라는 메세지가 나오면서 순식간에 병합이 일어납니다. 즉, merge 할 test 브랜치가 master 브랜치가 가리키는 것보다 앞으로 진행한 commit 이기 때문에 master 브랜치 포인터는 최신 커밋으로 이동하는 방식을 일컫는 말입니다. push 작업을 한 뒤 github에 master 브랜치 작업내역을 확인합니다. 123$ git branch --merged$ git branch -d 'branch name'$ git push origin --delete 'remote branch name' merged 옵션을 통하여 merge한 브랜치 list를 보여줍니다. 로컬 브랜치(master, test) 코드가 동일해졌으니 d 옵션을 주어 필요없는 test 브랜치를 삭제해줍니다. 원격 브랜치(remotes/origin/master, remotes/origin/test) 코드도 동일해졌으니 원격 test 브랜치도 삭제시켜줍니다. delete 옵션을 통해 푸쉬합니다. 1$ git log --all --decorate --graph --oneline --stat 왼쪽 터미널은 test 브랜치를 삭제하고 나서 log를 확인한 것이며 오른쪽 터미널은 브랜치를 삭제하기 전의 log 캡쳐 사진입니다. commit history를 확인합니다. all - refs/의 모든 참조들의 log들을 출력시켜줍니다. decorate - commit id 오른쪽에 현재 위치해있는 브랜치 name을 보여줍니다. graph - commit id 왼쪽에 line을 생성하여 commit log를 좀 더 시각화 시켜줍니다. 브랜치들간의 차이를 좀 더 쉽게 파악할 수 있습니다. oneline - 한줄로 요약해서 보여줍니다. stat - 변경된 파일들의 목록을 보여줍니다. Wrap-up지금까지 git의 기초와 일반적인 workflow에 대해 알아보았습니다. 실무에서는 이보다 훨씬 더 복잡한 구조로 되어 있기 때문에 기본 개념을 제대로 이해하셔야 conflict 났을 경우 대처하기가 쉽습니다. command line 이 익숙하지 않은 분들에게는 SourceTree라는 GUI 툴을 추천합니다. ReferenceGit documentation - 브랜치와 Merge의 기초 working directory->staging area: git add staging area->local repo: git commit local repo->remote repo: git push remote repo-->working directory: git pull local repo-->working directory: git checkout local repo-->working directory: git merge{\"scale\":1,\"line-width\":2,\"line-length\":50,\"text-margin\":10,\"font-size\":12,\"theme\":\"simple\"} var code = document.getElementById(\"sequence-0-code\").value; var options = JSON.parse(decodeURIComponent(document.getElementById(\"sequence-0-options\").value)); var diagram = Diagram.parse(code); diagram.drawSVG(\"sequence-0\", options);","categories":[{"name":"Ops","slug":"Ops","permalink":"http://jason0853.github.io/categories/Ops/"},{"name":"Git","slug":"Ops/Git","permalink":"http://jason0853.github.io/categories/Ops/Git/"}],"tags":[{"name":"git","slug":"git","permalink":"http://jason0853.github.io/tags/git/"}]}]}